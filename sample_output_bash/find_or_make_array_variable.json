{
  "address": "0x965d0",
  "rules": [
    "hash data using aphash/8f862f7edc7641079bc7234f31736b95",
    "write file on Windows/3772193b67764012b0d59bdbe7fe5d9a",
    "validate payment card number using luhn algorithm with no lookup table/62880de69d1941c9b68bc888f21444df",
    "encrypt data using Curve25519/f2994133291147a090851ed21e9c381b",
    "hash data with CRC32/6874091fc240423886717926d876159d",
    "check for kernel debugger via shared user data structure/300b95c5a43549898dd5e28afc704e20",
    "check for kernel debugger via shared user data structure/47a8170337e74f7ca5a6c64253eb43bf"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp",
    "mov     rbp, rsp",
    "push    r13",
    "mov     r13d, esi",
    "push    r12",
    "mov     r12, rdi",
    "push    rbx",
    "sub     rsp, 0x8",
    "call    find_variable",
    "test    rax, rax",
    "je      0x96700",
    "mov     esi, 0x1",
    "mov     rdi, r12",
    "call    find_variable_last_nameref",
    "mov     rbx, rax",
    "test    rax, rax",
    "je      0x96788",
    "mov     rbx, rax",
    "mov     eax, dword [rax+0x28 {Elf64_Header::section_header_offset.d}]",
    "and     r13d, 0x2",
    "je      0x967f0",
    "mov     eax, dword [rax+0x28 {Elf64_Header::section_header_offset.d}]",
    "not     eax",
    "test    ah, 0x18",
    "je      0x96840",
    "and     r13d, 0x2",
    "jne     0x96690",
    "test    eax, 0x4002",
    "jne     0x966e8",
    "add     rsp, 0x8",
    "mov     rdi, r12",
    "pop     rbx",
    "pop     r12",
    "pop     r13",
    "pop     rbp",
    "jmp     make_new_array_variable",
    "lea     rax, [rel global_variables]",
    "mov     rdi, r12",
    "mov     rax, qword [rax]",
    "mov     rsi, qword [rax+0x20]",
    "call    sub_54b40",
    "mov     edi, 0x400",
    "mov     rbx, rax",
    "call    hash_create",
    "or      dword [rbx+0x28 {Elf64_Header::section_header_offset.d}], 0x40 {Elf64_Header::section_header_offset.d}",
    "mov     qword [rbx+0x8 {Elf64_Header::ident.abi_version}], rax {Elf64_Header::ident.pad[0]} {Elf64_Header::ident.pad[1]} {Elf64_Header::ident.pad[2]} {Elf64_Header::ident.pad[3]} {Elf64_Header::ident.pad[4]} {Elf64_Header::ident.pad[5]} {Elf64_Header::ident.pad[6]}",
    "jmp     0x9661a",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_132b80]  {\"%s: removing nameref attribute\"}",
    "xor     edi, edi",
    "call    dcgettext",
    "mov     rsi, r12",
    "mov     rdi, rax",
    "xor     eax, eax",
    "call    internal_warning",
    "and     dword [rbx+0x28 {Elf64_Header::section_header_offset.d}], 0xfffff7ff {Elf64_Header::section_header_offset.d}",
    "jmp     0x96723",
    "mov     eax, dword [rbx+0x28 {Elf64_Header::section_header_offset.d}]",
    "test    ah, 0x8",
    "je      0x965fb",
    "test    al, 0x4",
    "jne     0x96808",
    "test    al, 0x44",
    "je      0x96770",
    "test    al, 0x2",
    "jne     0x967c0",
    "add     rsp, 0x8",
    "mov     rax, rbx",
    "pop     rbx",
    "pop     r12",
    "pop     r13",
    "pop     rbp",
    "retn    ",
    "test    r13b, 0x1",
    "je      0x9660c",
    "mov     rbx, qword [rbx+0x8 {Elf64_Header::ident.abi_version}] {Elf64_Header::ident.pad[0]} {Elf64_Header::ident.pad[1]} {Elf64_Header::ident.pad[2]} {Elf64_Header::ident.pad[3]} {Elf64_Header::ident.pad[4]} {Elf64_Header::ident.pad[5]} {Elf64_Header::ident.pad[6]}",
    "test    rbx, rbx",
    "je      0x96741",
    "lea     rax, [rel last_command_exit_value]",
    "mov     esi, 0x1",
    "lea     rdi, [rel data_158490]",
    "mov     dword [rel data_158490], 0x1",
    "mov     dword [rax], 0x1",
    "call    set_pipestatus_array",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_133780]  {\"%s: cannot convert indexed to as\u2026\"}",
    "jmp     0x967cc",
    "test    al, 0x40",
    "jne     0x9661a",
    "add     rsp, 0x8",
    "mov     rdi, rbx",
    "pop     rbx",
    "pop     r12",
    "pop     r13",
    "pop     rbp",
    "jmp     convert_var_to_array",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_11fcf9]  {\"%s: readonly variable\"}",
    "xor     ebx, ebx",
    "jmp     0x9661a",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_11fa8b]  {\"`%s': not a valid identifier\"}",
    "xor     edi, edi",
    "call    dcgettext",
    "mov     rsi, rbx",
    "xor     ebx, ebx",
    "mov     rdi, rax",
    "xor     eax, eax",
    "call    builtin_error",
    "jmp     0x9661a",
    "cmp     byte [rbx], 0x0",
    "jne     0x96630",
    "xor     edi, edi",
    "xor     ebx, ebx",
    "call    dcgettext",
    "mov     rsi, r12",
    "mov     rdi, rax",
    "xor     eax, eax",
    "call    report_error",
    "jmp     0x9661a",
    "add     rsp, 0x8",
    "mov     rdi, rbx",
    "pop     rbx",
    "pop     r12",
    "pop     r13",
    "pop     rbp",
    "jmp     convert_var_to_assoc",
    "mov     rdi, rbx",
    "call    legal_identifier",
    "test    eax, eax",
    "je      0x96741",
    "test    r13b, 0x2",
    "je      0x966b8",
    "mov     rdi, rbx",
    "call    make_new_array_variable",
    "mov     rbx, rax",
    "test    rax, rax",
    "je      0x967f0",
    "lea     rax, [rel global_variables]",
    "mov     rdi, rbx",
    "mov     rax, qword [rax]",
    "mov     rsi, qword [rax+0x20]",
    "call    sub_54b40",
    "mov     edi, 0x400",
    "mov     rbx, rax",
    "call    hash_create",
    "mov     edx, dword [rbx+0x28 {Elf64_Header::section_header_offset.d}]",
    "mov     qword [rbx+0x8 {Elf64_Header::ident.abi_version}], rax {Elf64_Header::ident.pad[0]} {Elf64_Header::ident.pad[1]} {Elf64_Header::ident.pad[2]} {Elf64_Header::ident.pad[3]} {Elf64_Header::ident.pad[4]} {Elf64_Header::ident.pad[5]} {Elf64_Header::ident.pad[6]}",
    "mov     eax, edx",
    "or      eax, 0x40",
    "and     r13d, 0x1",
    "mov     dword [rbx+0x28 {Elf64_Header::section_header_offset.d}], eax",
    "je      0x96690",
    "and     r13d, 0x1",
    "mov     eax, dword [rax+0x28]",
    "je      0x96612",
    "and     edx, 0x4002",
    "jne     0x966e8",
    "test    eax, 0x4002",
    "je      0x96612",
    "nop     word [rax+rax]",
    "nop     dword [rax]"
  ]
}