{
  "address": "0xd25d0",
  "rules": [
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a"
  ],
  "disassembly": [
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "push    r14 {__saved_r14}",
    "push    r13 {__saved_r13}",
    "push    r12 {__saved_r12}",
    "push    rbx {__saved_rbx}",
    "mov     rbx, rdi",
    "sub     rsp, 0x28",
    "mov     rax, qword [fs:0x28]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "xor     eax, eax  {0x0}",
    "call    mbsmbchar",
    "test    rax, rax",
    "je      0xd26b0",
    "mov     rdi, rbx",
    "call    udequote_pathname",
    "jmp     0xd2672",
    "mov     rdi, rbx",
    "lea     r14, [rbp-0x48 {var_50}]",
    "call    strlen",
    "mov     rsi, rbx",
    "mov     rdi, r14 {var_50}",
    "mov     r12, rax",
    "xor     eax, eax  {0x0}",
    "call    sub_d4050",
    "cmp     rax, 0xffffffffffffffff",
    "je      0xd26b0",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "sub     rax, qword [fs:0x28]",
    "jne     0xd26ba",
    "mov     r13, qword [rbp-0x48 {var_50}]",
    "lea     r15, [rbp-0x40 {ps}]",
    "mov     rdi, r13",
    "call    wcdequote_pathname",
    "mov     rcx, r15 {ps}",
    "mov     rdx, r12",
    "mov     rsi, r14 {var_50}",
    "mov     rdi, rbx",
    "mov     qword [rbp-0x40 {ps}], 0x0",
    "call    wcsrtombs",
    "cmp     rax, 0xffffffffffffffff",
    "je      0xd2690",
    "call    __stack_chk_fail",
    "{ Does not return }",
    "add     rsp, 0x28",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "mov     rcx, r15 {ps}",
    "mov     rdx, r12",
    "mov     rsi, r14 {var_50}",
    "mov     rdi, rbx",
    "mov     qword [rbp-0x48 {var_50}], r13",
    "mov     qword [rbp-0x40 {ps}], 0x0",
    "call    xwcsrtombs",
    "jmp     0xd2665",
    "mov     rax, qword [rbp-0x48 {var_50}]",
    "test    rax, rax",
    "je      0xd2665",
    "mov     byte [rbx+r12], 0x0",
    "mov     rdi, r13",
    "call    free",
    "mov     eax, dword [rax]",
    "test    eax, eax",
    "jne     0xd2690"
  ],
  "high level IL": [
    "char* rbx = arg1",
    "void* fsbase",
    "int64_t rax = *(fsbase + 0x28)",
    "char* rax_2 = mbsmbchar(arg1)",
    "wchar_t* var_50",
    "uint64_t len",
    "int64_t rax_4",
    "if (rax_2 != 0)",
    "len = strlen(rbx)",
    "rax_4 = sub_d4050(&var_50, rbx)",
    "if (rax_2 == 0 || rax_4 == -1)",
    "udequote_pathname(rbx)",
    "wchar_t* r13_1 = var_50",
    "wcdequote_pathname(r13_1)",
    "int64_t ps = 0",
    "if (wcsrtombs(rbx, &var_50, len, &ps) == -1)",
    "label_d269c:",
    "var_50 = r13_1",
    "ps = 0",
    "xwcsrtombs(rbx, &var_50, len, &ps)",
    "wchar_t* rax_6 = var_50",
    "if (rax_6 != 0 && *rax_6 != 0)",
    "goto label_d269c",
    "rbx[len] = 0",
    "free(r13_1)",
    "if (rax == *(fsbase + 0x28))",
    "return rax - *(fsbase + 0x28)",
    "__stack_chk_fail()",
    "noreturn"
  ]
}