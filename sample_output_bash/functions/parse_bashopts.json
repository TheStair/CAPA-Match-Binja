{
  "address": "0xccc90",
  "rules": [
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a",
    "contain loop",
    "connect to WMI namespace via WbemLocator/472165133b624c67bbc5d17c3915a018",
    "populate SysWhispers2 syscall list/074b321f7b7941958bfc8de4f583b5b2"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "push    r14 {__saved_r14}",
    "lea     r14, [rel data_11f1dc]",
    "push    r13 {__saved_r13}",
    "push    r12 {__saved_r12}",
    "push    rbx {__saved_rbx}",
    "sub     rsp, 0x28",
    "mov     qword [rbp-0x48 {var_50}], rdi",
    "mov     rax, qword [fs:0x28]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "xor     eax, eax  {0x0}",
    "lea     rax, [rbp-0x3c {var_44}]",
    "mov     dword [rbp-0x3c {var_44}], 0x0",
    "mov     qword [rbp-0x50 {var_58}], rax {var_44}",
    "nop     ",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "sub     rax, qword [fs:0x28]",
    "jne     0xccd7f",
    "movzx   r13d, byte [rbx]",
    "mov     eax, 0x61",
    "xor     r15d, r15d  {0x0}",
    "mov     rsi, r14  {data_11f1dc, \"autocd\"}",
    "lea     r12, [rel data_156098]",
    "jmp     0xccd14",
    "call    __stack_chk_fail",
    "{ Does not return }",
    "add     rsp, 0x28",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "cmp     r13b, al",
    "jne     0xccd00",
    "mov     rsi, qword [r12]",
    "add     r12, 0x18",
    "add     r15d, 0x1",
    "test    rsi, rsi",
    "je      0xccd54",
    "mov     rdi, rbx",
    "call    strcmp",
    "test    eax, eax",
    "jne     0xccd00",
    "mov     rdi, rbx",
    "call    free",
    "jmp     0xcccd0",
    "movzx   eax, byte [rsi]",
    "movsxd  rcx, r15d",
    "lea     rax, [rcx+rcx*2]",
    "lea     rcx, [rel data_156080]",
    "lea     rax, [rcx+rax*8]",
    "mov     rdx, qword [rax+0x8]",
    "mov     dword [rdx], 0x1",
    "mov     rdx, qword [rax+0x10]",
    "test    rdx, rdx",
    "je      0xccd54",
    "mov     rsi, qword [rbp-0x50 {var_58}]",
    "mov     rdi, qword [rbp-0x48 {var_50}]",
    "call    extract_colon_unit",
    "mov     rbx, rax",
    "test    rax, rax",
    "je      0xccd61",
    "mov     rdi, qword [rax]",
    "mov     esi, 0x1",
    "call    rdx"
  ],
  "high level IL": [
    "void* fsbase",
    "int64_t rax = *(fsbase + 0x28)",
    "int32_t var_44 = 0",
    "while (true)",
    "char* rax_1 = extract_colon_unit(arg1, &var_44)",
    "if (rax_1 == 0)",
    "break",
    "char r13_1 = *rax_1",
    "char rax_2 = 0x61",
    "int32_t r15_1 = 0",
    "char* rsi_2 = \"autocd\"",
    "char** r12_1 = &data_156098",
    "while (true)",
    "if (r13_1 == rax_2 && strcmp(rax_1, rsi_2) == 0)",
    "int64_t rcx_1 = sx.q(r15_1)",
    "*(&data_156088)[rcx_1 * 3] = 1",
    "int64_t rdx_2 = *(rcx_1 * 0x18 + 0x156090)",
    "if (rdx_2 != 0)",
    "rdx_2((&data_156080)[rcx_1 * 3], 1)",
    "break",
    "rsi_2 = *r12_1",
    "r12_1 = &r12_1[3]",
    "r15_1 += 1",
    "if (rsi_2 == 0)",
    "break",
    "rax_2 = *rsi_2",
    "free(rax_1)",
    "if (rax == *(fsbase + 0x28))",
    "return rax - *(fsbase + 0x28)",
    "__stack_chk_fail()",
    "noreturn"
  ]
}