{
  "address": "0x1132c0",
  "rules": [
    "check for time delay via GetTickCount/173be9e5d4d440c09f85224fcb793b6a",
    "connect to WMI namespace via WbemLocator/472165133b624c67bbc5d17c3915a018",
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a",
    "contain loop",
    "check for trap flag exception/457e23e248b947a19120dac4e8cc1687",
    "encrypt data using TEA/125a16c5ca784de5b4ec344bb7f45260/b9272fb9d4744824873ec7d3c8013c6c",
    "decrypt data using TEA/ab7f9f2b007f48f680d6bcb7da99c5f3/228e05560ef647b99ab605fac0daf580",
    "encrypt data using XXTEA/55da17cb2d2b4f30ac54eab7c66fa3d3/053ec9add6b744e4993f7dc6e62f924f",
    "populate SysWhispers2 syscall list/074b321f7b7941958bfc8de4f583b5b2",
    "encrypt data using XTEA/5c1c4c90f3124e8b8e496a40b647bc29/214603c8f1d64a2ea9add8dd99e7e802"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "xor     r15d, r15d  {0x0}",
    "push    r14 {__saved_r14}",
    "lea     r14, [rel data_1349e8]",
    "push    r13 {__saved_r13}",
    "xor     r13d, r13d  {0x0}",
    "push    r12 {__saved_r12}",
    "mov     r12, rdi",
    "push    rbx {__saved_rbx}",
    "mov     rdi, r12",
    "lea     rbx, [rel jump_table_138d74]",
    "sub     rsp, 0x68",
    "mov     qword [rbp-0x68 {var_70}], rsi",
    "mov     rsi, r14  {data_1349e8, \"abcdefgjko:prsuvA:G:W:P:S:X:F:C:\u2026\"}",
    "mov     qword [rbp-0x80 {var_88}], rdx",
    "mov     qword [rbp-0x88 {var_90}], rcx",
    "mov     rax, qword [fs:0x28]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "lea     rax, [rel loptend]",
    "mov     qword [rbp-0x78 {var_80}], 0x0",
    "mov     qword [rel data_168d30], 0x0",
    "mov     dword [rel data_168d28], 0x1",
    "mov     qword [rax], 0x0  {loptend}",
    "lea     rax, [rel lcurrent]",
    "mov     qword [rax], 0x0  {lcurrent}",
    "call    internal_getopt",
    "cmp     eax, 0xffffffff",
    "je      0x1133fa",
    "mov     rax, qword [rbp-0x80 {var_88}]",
    "mov     rcx, qword [rbp-0x78 {var_80}]",
    "mov     qword [rax], r15",
    "mov     rax, qword [rbp-0x88 {var_90}]",
    "mov     qword [rax], rcx",
    "mov     eax, r13d",
    "xor     eax, 0x1",
    "jmp     0x1133b0",
    "nop     dword [rax]",
    "mov     rdx, qword [rbp-0x38 {var_40}]",
    "sub     rdx, qword [fs:0x28]",
    "jne     0x1138c4",
    "call    builtin_help",
    "jmp     0x1133a5",
    "sub     eax, 0x41",
    "cmp     eax, 0x35",
    "ja      0x1133a0",
    "call    __stack_chk_fail",
    "{ Does not return }",
    "add     rsp, 0x68",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "mov     eax, 0x102",
    "nop     word [rax+rax]",
    "{Case 0x1, 0x7, 0x9-0xe, 0x10-0x11, 0x13-0x15, 0x18-0x1f, 0x27-0x28, 0x2b-0x2d, 0x30, 0x33}",
    "call    builtin_usage",
    "movsxd  rax, dword [rbx+rax*4]",
    "add     rax, rbx",
    "jmp     rax",
    "{Case 0x35}",
    "or      r15, 0x800000",
    "nop     ",
    "{Case 0x34}",
    "or      r15, 0x400000",
    "jmp     0x1133e0",
    "{Case 0x32}",
    "or      r15, 0x20000",
    "jmp     0x1133e0",
    "{Case 0x31}",
    "mov     rax, qword [rbp-0x68 {var_70}]",
    "test    rax, rax",
    "je      0x113856",
    "{Case 0x2f}",
    "mov     rax, qword [rbp-0x68 {var_70}]",
    "test    rax, rax",
    "je      0x113373",
    "{Case 0x2e}",
    "lea     rax, [rel list_optarg]",
    "lea     rdx, [rel data_1551d0]",
    "xor     r13d, r13d  {0x0}",
    "lea     rsi, [rel data_121bb2]  {\"bashdefault\"}",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rbp-0x70 {var_78_1}], rax",
    "movzx   r8d, byte [rax]",
    "mov     eax, 0x62",
    "jmp     0x1134c7",
    "{Case 0x2a}",
    "or      r15, 0x8000",
    "jmp     0x1133e0",
    "{Case 0x26}",
    "or      r15, 0x800",
    "jmp     0x1133e0",
    "{Case 0x25}",
    "or      r15, 0x200",
    "jmp     0x1133e0",
    "{Case 0x29}",
    "or      r15, 0x4000",
    "jmp     0x1133e0",
    "{Case 0x24}",
    "or      r15, 0x100",
    "jmp     0x1133e0",
    "{Case 0x23}",
    "or      r15, 0x20",
    "jmp     0x1133e0",
    "{Case 0x22}",
    "or      r15, 0x10",
    "jmp     0x1133e0",
    "{Case 0x21}",
    "or      r15, 0x8",
    "jmp     0x1133e0",
    "{Case 0x20}",
    "or      r15, 0x1",
    "jmp     0x1133e0",
    "{Case 0x17}",
    "lea     rax, [rel list_optarg]",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rel data_168fc0], rax",
    "jmp     0x1133e0",
    "{Case 0x16}",
    "lea     rax, [rel list_optarg]",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rel data_168fa8], rax",
    "jmp     0x1133e0",
    "{Case 0x12}",
    "lea     rax, [rel list_optarg]",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rel data_168fb8], rax",
    "jmp     0x1133e0",
    "{Case 0xf}",
    "lea     rax, [rel list_optarg]",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rel data_168fb0], rax",
    "jmp     0x1133e0",
    "{Case 0x8}",
    "mov     rax, qword [rbp-0x68 {var_70}]",
    "test    rax, rax",
    "je      0x113896",
    "{Case 0x6}",
    "lea     rax, [rel list_optarg]",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rel data_168fa0], rax",
    "jmp     0x1133e0",
    "{Case 0x5}",
    "lea     rax, [rel list_optarg]",
    "lea     rdi, [rbp-0x50 {list_optarg_4}]",
    "mov     dword [rbp-0x48 {var_50_1}], 0x0",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rel data_168fc8], rax",
    "mov     qword [rbp-0x50 {list_optarg_4}], rax",
    "lea     rax, [rel posixly_correct]",
    "mov     esi, dword [rax]  {posixly_correct}",
    "call    check_identifier",
    "mov     r13, qword [rel data_168fc8]",
    "test    eax, eax",
    "je      0x1136b1",
    "{Case 0x4}",
    "mov     rax, qword [rbp-0x68 {var_70}]",
    "test    rax, rax",
    "je      0x1137d2",
    "{Case 0x3}",
    "mov     rax, qword [rbp-0x68 {var_70}]",
    "test    rax, rax",
    "je      0x113800",
    "{Case 0x2}",
    "lea     rax, [rel list_optarg]",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rel data_168fd0], rax",
    "jmp     0x1133e0",
    "{Case 0x0}",
    "lea     rax, [rel list_optarg]",
    "lea     rdx, [rel data_155278]",
    "xor     r13d, r13d  {0x0}",
    "lea     rsi, [rel data_11fa38]  {\"alias\"}",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rbp-0x70 {var_78_1}], rax",
    "movzx   r8d, byte [rax]",
    "mov     eax, 0x61",
    "jmp     0x113787",
    "cmp     eax, 0xffffff9d",
    "je      0x1137c8",
    "mov     rsi, r14  {data_1349e8, \"abcdefgjko:prsuvA:G:W:P:S:X:F:C:\u2026\"}",
    "mov     rdi, r12",
    "mov     r13d, 0x1",
    "call    internal_getopt",
    "cmp     eax, 0xffffffff",
    "jne     0x113358",
    "mov     edx, 0x5",
    "xor     edi, edi  {0x0}",
    "lea     rsi, [rel data_11f222]  {\"%s: invalid option\"}",
    "call    dcgettext",
    "lea     rsi, [rel data_122f4e]",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "call    builtin_usage",
    "jmp     0x1133a5",
    "mov     dword [rax+0x4], 0x1",
    "jmp     0x1133e0",
    "lea     rsi, [rel data_11f222]  {\"%s: invalid option\"}",
    "xor     edi, edi  {0x0}",
    "mov     edx, 0x5",
    "call    dcgettext",
    "lea     rsi, [rel data_11f753]",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "nop     word [rax+rax]",
    "mov     dword [rax], 0x1",
    "jmp     0x1133e0",
    "cmp     r8b, al",
    "jne     0x1134b0",
    "mov     edx, 0x5",
    "xor     edi, edi  {0x0}",
    "lea     rsi, [rel data_11f222]  {\"%s: invalid option\"}",
    "call    dcgettext",
    "lea     rsi, [rel data_121baf]",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "call    builtin_usage",
    "jmp     0x1133a5",
    "mov     dword [rax+0x10], 0x1",
    "jmp     0x1133e0",
    "xor     edi, edi  {0x0}",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_11fa8b]  {\"`%s': not a valid identifier\"}",
    "call    dcgettext",
    "mov     rsi, r13",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "jmp     0x1133a5",
    "lea     rsi, [rel data_120c5d]  {\"()<>;&| \\t\\n\"}",
    "mov     rdi, r13",
    "call    strpbrk",
    "test    rax, rax",
    "je      0x1133e0",
    "mov     edx, 0x5",
    "xor     edi, edi  {0x0}",
    "lea     rsi, [rel data_11f222]  {\"%s: invalid option\"}",
    "call    dcgettext",
    "lea     rsi, [rel data_121bac]",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "call    builtin_usage",
    "jmp     0x1133a5",
    "mov     dword [rax+0xc], 0x1",
    "jmp     0x1133e0",
    "mov     edx, 0x5",
    "xor     edi, edi  {0x0}",
    "lea     rsi, [rel data_11f222]  {\"%s: invalid option\"}",
    "call    dcgettext",
    "lea     rsi, [rel data_121ba9]",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "call    builtin_usage",
    "jmp     0x1133a5",
    "mov     dword [rax+0x8], 0x1",
    "jmp     0x1133e0",
    "cmp     al, r8b",
    "jne     0x113770",
    "mov     rsi, qword [rdx]",
    "add     rdx, 0x10",
    "add     r13d, 0x1",
    "test    rsi, rsi",
    "je      0x113888",
    "mov     rdi, qword [rbp-0x70 {var_78_1}]",
    "mov     qword [rbp-0x60 {var_68_1}], rdx",
    "mov     byte [rbp-0x51 {var_59_1}], r8b",
    "call    strcmp",
    "movzx   r8d, byte [rbp-0x51 {var_59_1}]",
    "mov     rdx, qword [rbp-0x60 {var_68_1}]",
    "test    eax, eax",
    "jne     0x1134b0",
    "mov     rsi, qword [rdx]",
    "add     rdx, 0x18",
    "add     r13d, 0x1",
    "test    rsi, rsi",
    "je      0x113830",
    "mov     rdi, qword [rbp-0x70 {var_78_1}]",
    "mov     qword [rbp-0x60 {var_68_2}], rdx",
    "mov     byte [rbp-0x51 {var_59_2}], r8b",
    "call    strcmp",
    "movzx   r8d, byte [rbp-0x51 {var_59_2}]",
    "mov     rdx, qword [rbp-0x60 {var_68_2}]",
    "test    eax, eax",
    "jne     0x113770",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_1210b0]  {\"%s: invalid option name\"}",
    "jmp     0x11383c",
    "movzx   eax, byte [rsi]",
    "movsxd  rcx, r13d",
    "lea     rax, [rel data_1551c0]",
    "shl     rcx, 0x4",
    "mov     rax, qword [rax+rcx+0x8]",
    "or      qword [rbp-0x78 {var_80}], rax",
    "jmp     0x1133e0",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_122f51]  {\"%s: invalid action name\"}",
    "movzx   eax, byte [rsi]",
    "movsxd  rcx, r13d",
    "lea     rax, [rel data_155260]",
    "lea     rdx, [rcx+rcx*2]",
    "or      r15, qword [rax+rdx*8+0x8]",
    "jmp     0x1133e0",
    "xor     edi, edi  {0x0}",
    "call    dcgettext",
    "mov     rsi, qword [rbp-0x70 {var_78_1}]",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "jmp     0x1133a5"
  ],
  "high level IL": [
    "int64_t r15 = 0",
    "int32_t r13 = 0",
    "void* fsbase",
    "int64_t rax = *(fsbase + 0x28)",
    "int64_t var_80 = 0",
    "__builtin_memset(&data_168d30, 0, 0x18)",
    "data_168d28 = 1",
    "int32_t rax_1 = internal_getopt(arg1, \"abcdefgjko:prsuvA:G:W:P:S:X:F:C:\u2026\")",
    "uint64_t result",
    "if (rax_1 == 0xffffffff)",
    "label_113402:",
    "*arg3 = r15",
    "*arg4 = var_80",
    "result = zx.q(r13) ^ 1",
    "while (true)",
    "if (rax_1 == 0xffffff9d)",
    "builtin_help()",
    "uint64_t rax_2 = zx.q(rax_1 - 0x41)",
    "if (rax_2.d u> 0x35)",
    "builtin_usage()",
    "switch (rax_2)",
    "case 0",
    "char const (** const rdx_3)[0x9] = &data_155278",
    "int32_t r13_3 = 0",
    "char const* const rsi_4 = \"alias\"",
    "uint64_t list_optarg_3 = list_optarg",
    "char r8_2 = *list_optarg_3",
    "char const rax_26 = 0x61",
    "while (true)",
    "if (rax_26 == r8_2 && strcmp(list_optarg_3, rsi_4) == 0)",
    "r15 |= *(sx.q(r13_3) * 0x18 + 0x155268)",
    "goto label_1133e6",
    "rsi_4 = *rdx_3",
    "rdx_3 = &rdx_3[3]",
    "r13_3 += 1",
    "if (rsi_4 == 0)",
    "break",
    "rax_26 = *rsi_4",
    "builtin_error(dcgettext(nullptr, \"%s: invalid action name\", 5), 0)",
    "case 1, 7, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0x10, 0x11, 0x13, 0x14, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x27, 0x28, 0x2b, 0x2c, 0x2d, 0x30, 0x33",
    "builtin_usage()",
    "case 2",
    "data_168fd0 = list_optarg",
    "goto label_1133e6",
    "case 3",
    "if (arg2 != 0)",
    "arg2[2] = 1",
    "goto label_1133e6",
    "builtin_error(dcgettext(nullptr, \"%s: invalid option\", 5), 0)",
    "builtin_usage()",
    "case 4",
    "if (arg2 != 0)",
    "arg2[3] = 1",
    "goto label_1133e6",
    "builtin_error(dcgettext(nullptr, \"%s: invalid option\", 5), 0)",
    "builtin_usage()",
    "case 5",
    "int32_t var_50_1 = 0",
    "uint64_t list_optarg_2 = list_optarg",
    "data_168fc8 = list_optarg_2",
    "uint64_t list_optarg_4 = list_optarg_2",
    "int32_t rax_20 = check_identifier(&list_optarg_4, posixly_correct)",
    "char* rax_21",
    "if (rax_20 != 0)",
    "rax_21 = strpbrk(data_168fc8, \"()<>;&| \\t\\n\")",
    "if (rax_20 != 0 && rax_21 == 0)",
    "goto label_1133e6",
    "builtin_error(dcgettext(nullptr, \"`%s': not a valid identifier\", 5), 0)",
    "case 6",
    "data_168fa0 = list_optarg",
    "goto label_1133e6",
    "case 8",
    "if (arg2 != 0)",
    "arg2[4] = 1",
    "goto label_1133e6",
    "builtin_error(dcgettext(nullptr, \"%s: invalid option\", 5), 0)",
    "builtin_usage()",
    "case 0xf",
    "data_168fb0 = list_optarg",
    "goto label_1133e6",
    "case 0x12",
    "data_168fb8 = list_optarg",
    "goto label_1133e6",
    "case 0x16",
    "data_168fa8 = list_optarg",
    "goto label_1133e6",
    "case 0x17",
    "data_168fc0 = list_optarg",
    "goto label_1133e6",
    "case 0x20",
    "r15 |= 1",
    "goto label_1133e6",
    "case 0x21",
    "r15 |= 8",
    "goto label_1133e6",
    "case 0x22",
    "r15 |= 0x10",
    "goto label_1133e6",
    "case 0x23",
    "r15 |= 0x20",
    "goto label_1133e6",
    "case 0x24",
    "r15 |= 0x100",
    "goto label_1133e6",
    "case 0x25",
    "r15 |= 0x200",
    "goto label_1133e6",
    "case 0x26",
    "r15 |= 0x800",
    "goto label_1133e6",
    "case 0x29",
    "r15 |= 0x4000",
    "goto label_1133e6",
    "case 0x2a",
    "r15 |= 0x8000",
    "goto label_1133e6",
    "case 0x2e",
    "char** rdx_2 = &data_1551d0",
    "int32_t r13_1 = 0",
    "char* rsi_1 = \"bashdefault\"",
    "uint64_t list_optarg_1 = list_optarg",
    "char r8_1 = *list_optarg_1",
    "char rax_11 = 0x62",
    "while (true)",
    "if (r8_1 == rax_11 && strcmp(list_optarg_1, rsi_1) == 0)",
    "var_80 |= *((sx.q(r13_1) << 4) + 0x1551c8)",
    "goto label_1133e6",
    "rsi_1 = *rdx_2",
    "rdx_2 = &rdx_2[2]",
    "r13_1 += 1",
    "if (rsi_1 == 0)",
    "break",
    "rax_11 = *rsi_1",
    "builtin_error(dcgettext(nullptr, \"%s: invalid option name\", 5), 0)",
    "case 0x2f",
    "if (arg2 != 0)",
    "*arg2 = 1",
    "goto label_1133e6",
    "builtin_error(dcgettext(nullptr, \"%s: invalid option\", 5), 0)",
    "builtin_usage()",
    "case 0x31",
    "if (arg2 != 0)",
    "arg2[1] = 1",
    "goto label_1133e6",
    "builtin_error(dcgettext(nullptr, \"%s: invalid option\", 5), 0)",
    "builtin_usage()",
    "case 0x32",
    "r15 |= &__elf_rela_table[0x48].r_addend",
    "goto label_1133e6",
    "case 0x34",
    "r15 |= 0x400000",
    "goto label_1133e6",
    "case 0x35",
    "r15 |= 0x800000",
    "label_1133e6:",
    "r13 = 1",
    "rax_1 = internal_getopt(arg1, \"abcdefgjko:prsuvA:G:W:P:S:X:F:C:\u2026\")",
    "if (rax_1 == 0xffffffff)",
    "goto label_113402",
    "continue",
    "result = 0x102",
    "break",
    "*(fsbase + 0x28)",
    "if (rax == *(fsbase + 0x28))",
    "return result",
    "__stack_chk_fail()",
    "noreturn"
  ]
}