{
  "address": "0xeeed0",
  "rules": [
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a",
    "write file on Windows/dbc9cc37967145a499adfa89f5005055",
    "contain loop",
    "encrypt data using TEA/125a16c5ca784de5b4ec344bb7f45260/b9272fb9d4744824873ec7d3c8013c6c",
    "decrypt data using TEA/ab7f9f2b007f48f680d6bcb7da99c5f3/228e05560ef647b99ab605fac0daf580",
    "encrypt data using XXTEA/55da17cb2d2b4f30ac54eab7c66fa3d3/053ec9add6b744e4993f7dc6e62f924f",
    "populate SysWhispers2 syscall list/074b321f7b7941958bfc8de4f583b5b2",
    "encrypt data using XTEA/5c1c4c90f3124e8b8e496a40b647bc29/214603c8f1d64a2ea9add8dd99e7e802"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "push    r14 {__saved_r14}",
    "push    r13 {__saved_r13}",
    "mov     r13, rsi",
    "push    r12 {__saved_r12}",
    "mov     r12, rdi",
    "push    rbx {__saved_rbx}",
    "sub     rsp, 0x28",
    "mov     rax, qword [rel data_1604d8]",
    "mov     rsi, qword [rax]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "test    rsi, rsi",
    "je      0xef112",
    "mov     qword [rbp-0x48 {var_50_1}], 0x10",
    "xor     ebx, ebx  {0x0}",
    "xor     r14d, r14d  {0x0}",
    "mov     qword [rbp-0x40 {bytes}], 0x20",
    "jmp     0xeefeb",
    "lea     r15, [rax+0x10]",
    "xor     r14d, r14d  {0x0}",
    "mov     rax, r15",
    "jmp     0xeef1f",
    "lea     r9, [rel data_1604e0]",
    "cmp     qword [rbp-0x38 {var_40}], r9",
    "je      0xef0d8",
    "cmp     r13, qword [rax-0x8]",
    "jne     0xeef10",
    "mov     rdi, qword [rbp-0x40 {bytes}]",
    "call    malloc",
    "lea     r9, [rel data_1604e0]",
    "test    rax, rax",
    "mov     r15, rax",
    "je      0xef197",
    "mov     rsi, qword [rbp-0x40 {bytes}]",
    "mov     rdi, qword [rbp-0x38 {var_40}]",
    "call    realloc",
    "mov     r15, rax",
    "test    rax, rax",
    "je      0xef136",
    "add     rax, 0x10",
    "add     r14d, 0x1",
    "cmp     qword [rax-0x10], 0x0",
    "je      0xeef90",
    "cmp     r14d, 0x7",
    "jle     0xef12c",
    "mov     rsi, qword [rbp-0x40 {bytes}]",
    "lea     rdi, [rel data_11f01e]  {\"xmalloc\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     rcx, qword [rbp-0x40 {bytes}]",
    "mov     rdx, r14",
    "mov     rsi, r9  {data_1604e0}",
    "mov     rdi, r15",
    "mov     qword [rel data_1604d8], r15",
    "call    __memcpy_chk",
    "jmp     0xef01c",
    "mov     rsi, qword [rbp-0x40 {bytes}]",
    "lea     rdi, [rel data_11f045]  {\"xrealloc\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     qword [rel data_1604d8], r15",
    "mov     r14d, 0xffffffff",
    "jmp     0xeef2f",
    "mov     ebx, 0xffffffff",
    "jmp     0xeef76",
    "xor     ebx, ebx  {0x0}",
    "jmp     0xeef47",
    "mov     rdi, r12",
    "call    strlen",
    "lea     rdx, [rax+0x1]",
    "mov     rdi, rdx",
    "mov     qword [rbp-0x38 {var_40_1}], rdx",
    "call    malloc",
    "mov     rdx, qword [rbp-0x38 {var_40_1}]",
    "test    rax, rax",
    "mov     rcx, rax",
    "je      0xef14d",
    "mov     qword [rbp-0x40 {var_48_1}], rax",
    "mov     rsi, rdx",
    "lea     rdi, [rel data_11f01e]  {\"xmalloc\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     r8, qword [rel data_1604d8]",
    "mov     rsi, r12",
    "mov     rdi, rcx",
    "lea     r15, [r8+r14]",
    "mov     qword [rbp-0x38 {var_40_2}], r8",
    "call    __strcpy_chk",
    "mov     r8, qword [rbp-0x38 {var_40_2}]",
    "pxor    xmm0, xmm0",
    "mov     qword [r15+0x8], r13",
    "mov     qword [r15], rax",
    "mov     rax, qword [rbp-0x48 {var_50_1}]",
    "movups  xmmword [r8+rax], xmm0",
    "jmp     0xeef76",
    "add     rsp, 0x28",
    "mov     eax, ebx",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "mov     rdi, r12",
    "call    strcasecmp",
    "test    eax, eax",
    "jne     0xeef38",
    "mov     rsi, qword [r15]",
    "add     r15, 0x10",
    "add     ebx, 0x1",
    "test    rsi, rsi",
    "je      0xeefa0",
    "cmp     ebx, 0x7",
    "jle     0xef12c",
    "mov     edx, 0x10",
    "mov     eax, 0x1",
    "cmp     r14d, 0xffffffff",
    "jne     0xef080",
    "cmp     r14d, 0xffffffff",
    "jne     0xef080",
    "mov     r15, qword [rbp-0x38 {var_40}]",
    "movsxd  r13, r14d",
    "shl     r13, 0x4",
    "add     r15, r13",
    "mov     rdi, qword [r15]",
    "test    rdi, rdi",
    "je      0xef09b",
    "nop     dword [rax]",
    "mov     rdx, qword [rbp-0x38 {var_40}]",
    "movsxd  rax, ebx",
    "shl     rax, 0x4",
    "mov     qword [rdx+rax+0x8], r13",
    "mov     rdi, r12",
    "call    strlen",
    "lea     rbx, [rax+0x1]",
    "mov     rdi, rbx",
    "call    malloc",
    "mov     rcx, rax",
    "test    rax, rax",
    "je      0xef16f",
    "call    free",
    "mov     rcx, qword [rbp-0x38 {var_40}]",
    "mov     rsi, rax",
    "mov     r14, rdx",
    "add     rax, 0x1",
    "mov     rcx, qword [rcx+rdx]",
    "lea     rdx, [rdx+0x10]",
    "test    rcx, rcx",
    "jne     0xeefb8",
    "mov     ebx, esi",
    "add     esi, 0x2",
    "shl     rax, 0x4",
    "movsxd  rsi, esi",
    "mov     qword [rbp-0x48 {var_50_1}], rax",
    "shl     rsi, 0x4",
    "mov     qword [rbp-0x40 {bytes}], rsi",
    "mov     qword [rbp-0x38 {var_40_3}], rax",
    "mov     rsi, rbx",
    "lea     rdi, [rel data_11f01e]  {\"xmalloc\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     rdx, rbx",
    "mov     rsi, r12",
    "mov     rdi, rcx",
    "mov     ebx, r14d",
    "call    __strcpy_chk",
    "mov     qword [r15], rax",
    "jmp     0xeef76"
  ],
  "high level IL": [
    "void* oldmem = data_1604d8",
    "char* rsi = *oldmem",
    "int32_t rbx_1",
    "int64_t var_50_1",
    "uint64_t bytes",
    "uint64_t r14_1",
    "if (rsi == 0)",
    "var_50_1 = 0x10",
    "rbx_1 = 0",
    "r14_1 = 0",
    "bytes = 0x20",
    "label_eeff2:",
    "if (oldmem == &data_1604e0)",
    "void* rax_15 = malloc(bytes)",
    "if (rax_15 == 0)",
    "sub_a7f00()",
    "noreturn",
    "data_1604d8 = rax_15",
    "__memcpy_chk(rax_15, &data_1604e0, r14_1, bytes)",
    "void* rax_7 = realloc(oldmem, bytes)",
    "if (rax_7 == 0)",
    "sub_a7f00()",
    "noreturn",
    "data_1604d8 = rax_7",
    "uint64_t rdx_3 = strlen(arg1) + 1",
    "char* rax_9 = malloc(rdx_3)",
    "if (rax_9 == 0)",
    "char* var_48_1 = rax_9",
    "sub_a7f00()",
    "noreturn",
    "int128_t* r8_1 = data_1604d8",
    "char** r15_3 = r8_1 + r14_1",
    "char* rax_10 = __strcpy_chk(rax_9, arg1, rdx_3)",
    "r15_3[1] = arg2",
    "*r15_3 = rax_10",
    "*(r8_1 + var_50_1) = zx.o(0)",
    "void* r15_1 = oldmem + 0x10",
    "int32_t r14 = 0",
    "void* rax = r15_1",
    "while (true)",
    "if (arg2 != *(rax - 8))",
    "rax += 0x10",
    "r14 += 1",
    "if (*(rax - 0x10) == 0)",
    "r14 = -1",
    "continue",
    "goto label_eef2f",
    "if (r14 s> 7)",
    "label_eef2f:",
    "rbx_1 = 0",
    "while (strcasecmp(arg1, rsi) != 0)",
    "rsi = *r15_1",
    "r15_1 += 0x10",
    "rbx_1 += 1",
    "if (rsi == 0)",
    "uint64_t rdx_2 = 0x10",
    "int64_t rax_5 = 1",
    "if (r14 != 0xffffffff)",
    "goto label_ef08b",
    "int32_t rsi_1",
    "int64_t i",
    "rsi_1 = rax_5.d",
    "r14_1 = rdx_2",
    "rax_5 += 1",
    "i = *(oldmem + rdx_2)",
    "rdx_2 += 0x10",
    "do while (i != 0)",
    "rbx_1 = rsi_1",
    "var_50_1 = rax_5 << 4",
    "bytes = sx.q(rsi_1 + 2) << 4",
    "goto label_eeff2",
    "if (rbx_1 s> 7)",
    "if (r14 == 0xffffffff)",
    "*(oldmem + (sx.q(rbx_1) << 4) + 8) = arg2",
    "break",
    "label_ef08b:",
    "void* r15_5 = oldmem + (sx.q(r14) << 4)",
    "int64_t rdi_5 = *r15_5",
    "if (rdi_5 != 0)",
    "free(rdi_5)",
    "uint64_t rbx_2 = strlen(arg1) + 1",
    "char* rax_13 = malloc(rbx_2)",
    "if (rax_13 == 0)",
    "char* var_40_3 = rax_13",
    "sub_a7f00()",
    "noreturn",
    "rbx_1 = r14",
    "*r15_5 = __strcpy_chk(rax_13, arg1, rbx_2)",
    "break",
    "rbx_1 = -1",
    "break",
    "return zx.q(rbx_1)"
  ]
}