{
  "address": "0xc59d0",
  "rules": [
    "decrypt data using TEA/ab7f9f2b007f48f680d6bcb7da99c5f3/228e05560ef647b99ab605fac0daf580",
    "populate SysWhispers2 syscall list/074b321f7b7941958bfc8de4f583b5b2",
    "hash data using djb2/9bc6b91561f04ebca409510ba6653174",
    "log keystrokes via raw input data/5b32ff98460e406e86dc2ef8d82ba1a5",
    "contain loop",
    "check OS version/a792de506c61438eae0e98a59003db67",
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a",
    "encrypt data using TEA/125a16c5ca784de5b4ec344bb7f45260/b9272fb9d4744824873ec7d3c8013c6c",
    "hash data using aphash/e04b32e4de024de7af9a97876e98ac22",
    "hash data using jshash/495bfd597bd14a45826758e92f604bf6",
    "check Internet connectivity via WinINet/4ebebc1fd30e4dc8aec0393f85edc8f3",
    "encrypt data using XXTEA/55da17cb2d2b4f30ac54eab7c66fa3d3/053ec9add6b744e4993f7dc6e62f924f",
    "check OS version/35d8fd86b2bf418898b01c7af02eb9bc",
    "write file on Windows/dbc9cc37967145a499adfa89f5005055",
    "hash data with CRC32/b31bffa9a15b460bbcbd04d2822872fb",
    "encrypt data using XTEA/5c1c4c90f3124e8b8e496a40b647bc29/214603c8f1d64a2ea9add8dd99e7e802",
    "check for kernel debugger via shared user data structure/6be60e61779449d185f0bab196679834",
    "check for time delay via GetTickCount/173be9e5d4d440c09f85224fcb793b6a",
    "check for kernel debugger via shared user data structure/8dba58369c324a29b2fa79b10c98c249"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "push    r14 {__saved_r14}",
    "push    r13 {__saved_r13}",
    "push    r12 {__saved_r12}",
    "push    rbx {__saved_rbx}",
    "mov     rbx, rdi",
    "sub     rsp, 0x68",
    "mov     rax, qword [fs:0x28]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "xor     eax, eax  {0x0}",
    "cmp     byte [rel data_168f20], 0x0",
    "jne     0xc5a48  {data_168f20}",
    "mov     r12d, dword [rel data_168f00]",
    "test    r12d, r12d",
    "je      0xc5b90",
    "mov     r13d, 0x5361",
    "mov     byte [rel data_168f22], 0x48",
    "lea     rcx, [rel data_154f20]",
    "lea     rax, [rel data_168f23]",
    "mov     word [rel data_168f20], r13w  {0x5361}",
    "mov     edx, 0x52",
    "nop     dword [rax+rax]",
    "mov     dword [rel data_168f00], 0x10",
    "mov     edi, 0x100",
    "call    malloc",
    "mov     r12, rax",
    "test    rax, rax",
    "je      0xc6286",
    "lea     rax, [rel loptend]",
    "xor     r13d, r13d  {0x0}",
    "xor     r15d, r15d  {0x0}",
    "mov     dword [rel data_168ef0], 0x0",
    "mov     qword [rel data_168d30], 0x0",
    "lea     r12, [rel data_168f20]",
    "mov     qword [rax], 0x0  {loptend}",
    "lea     rax, [rel lcurrent]",
    "mov     dword [rel data_168d28], 0x1",
    "mov     qword [rax], 0x0  {lcurrent}",
    "add     rcx, 0x20",
    "mov     byte [rax], dl",
    "add     rax, 0x2",
    "mov     edx, dword [rcx-0x20]",
    "mov     byte [rax-0x1], 0x3b",
    "test    edx, edx",
    "jg      0xc5a30",
    "mov     byte [rax], 0x0",
    "mov     esi, 0x100",
    "lea     rdi, [rel data_11f01e]  {\"xmalloc\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     qword [rel data_168ef8], r12",
    "jmp     0xc5a58",
    "lea     rax, [rel loptend]",
    "mov     rdi, qword [rax]  {loptend}",
    "test    r13d, r13d",
    "jne     0xc6039",
    "cmp     edx, 0x48",
    "je      0xc5b80",
    "test    r15d, r15d",
    "mov     eax, 0x2",
    "lea     r13, [rbp-0x50 {rlimits}]",
    "cmove   r15d, eax  {0x2}",
    "lea     rax, [rbp-0x58 {rlimits_5}]",
    "lea     r12, [rel data_154f10]",
    "xor     ebx, ebx  {0x0}",
    "mov     qword [rbp-0x68 {var_70_2}], rax {rlimits_5}",
    "lea     r14, [rel data_12197f]",
    "jmp     0xc608f",
    "movsxd  r14, dword [rel data_168ef0]",
    "mov     eax, r14d",
    "test    r14d, r14d",
    "je      0xc5e6a",
    "or      r15d, 0x1",
    "jmp     0xc5aa0",
    "jg      0xc5b00",
    "mov     rsi, qword [rbp-0x68 {var_70_2}]",
    "mov     rdx, r13 {rlimits}",
    "mov     edi, ebx",
    "call    sub_bc500",
    "test    eax, eax",
    "je      0xc6068",
    "mov     rdx, qword [rel data_168ef8]",
    "mov     dword [rdx], 0x66",
    "test    rdi, rdi",
    "je      0xc6201",
    "jle     0xc6233",
    "mov     rsi, r12  {data_168f20}",
    "mov     rdi, rbx",
    "call    internal_getopt",
    "mov     edx, eax",
    "cmp     eax, 0xffffffff",
    "je      0xc5c10",
    "cmp     edx, 0x53",
    "je      0xc5b60",
    "cmp     edx, 0xffffff9d",
    "je      0xc5b70",
    "test    r15b, 0x2",
    "je      0xc60c8",
    "call    __errno_location",
    "mov     edi, dword [rax]",
    "cmp     edi, 0x16",
    "je      0xc607e",
    "mov     dword [rel data_168ef0], 0x1",
    "mov     r14d, 0x1",
    "mov     qword [rdx+0x8], 0x0",
    "jmp     0xc5c43",
    "mov     rax, qword [rdi+0x8]",
    "mov     r14d, 0x1",
    "mov     rdi, qword [rdi]",
    "mov     dword [rel data_168ef0], 0x1",
    "mov     rax, qword [rax]",
    "mov     qword [rdx+0x8], rax",
    "jmp     0xc5c43",
    "test    rdi, rdi",
    "jne     0xc5c8a",
    "mov     rdx, qword [rel data_168ef8]",
    "or      r15d, 0x2",
    "jmp     0xc5aa0",
    "cmp     edx, 0x61",
    "jne     0xc5b10",
    "call    builtin_help",
    "jmp     0xc5ad4",
    "cmp     edx, 0x3f",
    "jne     0xc5b10",
    "mov     rsi, qword [rbp-0x50 {rlimits}]",
    "jmp     0xc6072",
    "mov     rsi, qword [rbp-0x58 {rlimits_5}]",
    "mov     r11d, dword [r12+0x10]",
    "add     r12, 0x20",
    "add     ebx, 0x1",
    "test    r11d, r11d",
    "jle     0xc60ce",
    "call    strerror",
    "mov     rsi, qword [r12]",
    "mov     rdi, r14  {data_12197f, \"%s: cannot get limit: %s\"}",
    "mov     rdx, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "jmp     0xc607e",
    "mov     rcx, rdx",
    "xor     esi, esi  {0x0}",
    "nop     dword [rax+rax]",
    "mov     rcx, qword [rdi+0x8]",
    "test    rcx, rcx",
    "je      0xc5cae",
    "jmp     0xc5ada",
    "cmp     ebx, eax",
    "jne     0xc5c60",
    "mov     r8d, dword [rel data_168ef0]",
    "mov     eax, dword [rel data_168f00]",
    "mov     rcx, qword [rel data_168ef8]",
    "cmp     r8d, eax",
    "jge     0xc5bc0",
    "add     r13d, 0x1",
    "jmp     0xc5aa0",
    "mov     r13d, 0x102",
    "call    builtin_usage",
    "mov     edx, 0x1",
    "mov     edi, ebx",
    "call    sub_bc5b0",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "sub     rax, qword [fs:0x28]",
    "jne     0xc6256",
    "mov     rdx, qword [rel data_168ef8]",
    "mov     r14d, eax",
    "test    eax, eax",
    "jle     0xc5ada",
    "mov     rdx, qword [rel data_168ef8]",
    "shl     r14, 0x4",
    "lea     rdx, [rdx+r14-0x10]",
    "cmp     qword [rdx+0x8], 0x0",
    "je      0xc6227",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "sub     rax, qword [fs:0x28]",
    "jne     0xc6256",
    "mov     eax, dword [r8]",
    "add     r8, 0x20",
    "test    eax, eax",
    "jle     0xc6100",
    "add     esi, 0x1",
    "add     rcx, 0x10",
    "cmp     esi, r14d",
    "jl      0xc5c50",
    "add     eax, eax",
    "mov     dword [rbp-0x70 {var_78}], edx",
    "movsxd  r14, eax",
    "mov     dword [rel data_168f00], eax",
    "mov     dword [rbp-0x68 {var_70}], r8d",
    "shl     r14, 0x4",
    "test    rcx, rcx",
    "je      0xc6022",
    "movsxd  rax, r8d",
    "add     r8d, 0x1",
    "shl     rax, 0x4",
    "mov     dword [rel data_168ef0], r8d",
    "add     rcx, rax",
    "lea     rax, [rel list_optarg]",
    "mov     dword [rcx], edx",
    "mov     rax, qword [rax]  {list_optarg}",
    "mov     qword [rcx+0x8], rax",
    "jmp     0xc5aa0",
    "call    __stack_chk_fail",
    "{ Does not return }",
    "add     rsp, 0x68",
    "mov     eax, r13d",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "add     rsp, 0x68",
    "xor     edi, edi  {0x0}",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "jmp     sh_chkwrite",
    "test    r15d, r15d",
    "mov     eax, 0x2",
    "mov     dword [rbp-0x90 {var_98_1}], r13d",
    "sete    cl",
    "test    cl, cl",
    "cmove   eax, r15d",
    "and     eax, 0x2",
    "test    cl, cl",
    "mov     dword [rbp-0x8c {var_94_1}], eax",
    "mov     eax, 0x3",
    "cmove   eax, r15d",
    "xor     r12d, r12d  {0x0}",
    "mov     edi, eax",
    "and     eax, 0x1",
    "and     edi, 0x2",
    "mov     dword [rbp-0x88 {var_90_1}], eax",
    "lea     rax, [rbp-0x58 {rlimits_5}]",
    "mov     dword [rbp-0x84 {var_8c_1}], edi",
    "mov     qword [rbp-0x68 {var_70_1}], rax {rlimits_5}",
    "lea     rax, [rbp-0x60 {rlimits_4}]",
    "mov     qword [rbp-0x70 {var_78}], rax {rlimits_4}",
    "mov     rax, rdx",
    "nop     word [rax+rax]",
    "mov     rcx, qword [rcx]",
    "mov     qword [rdx+0x8], rcx",
    "jmp     0xc5cae",
    "xor     edi, edi  {0x0}",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_121998]  {\"`%c': bad command\"}",
    "call    dcgettext",
    "mov     esi, ebx",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "jmp     0xc5ad4",
    "mov     ebx, dword [rcx]",
    "lea     r8, [rel data_154f20]",
    "mov     eax, 0x52",
    "jmp     0xc5c6f",
    "test    rdi, rdi",
    "je      0xc5cc0",
    "mov     rdi, r14",
    "call    malloc",
    "mov     edx, dword [rbp-0x70 {var_78}]",
    "mov     r8d, dword [rbp-0x68 {var_70}]",
    "mov     rcx, rax",
    "jmp     0xc5bf4",
    "mov     rdi, rcx",
    "mov     rsi, r14",
    "call    realloc",
    "mov     r8d, dword [rbp-0x68 {var_70}]",
    "mov     edx, dword [rbp-0x70 {var_78}]",
    "mov     rcx, rax",
    "cmp     esi, eax",
    "jne     0xc5d40",
    "mov     eax, dword [rel data_168ef0]",
    "test    rcx, rcx",
    "je      0xc625b",
    "mov     rsi, r14",
    "lea     rdi, [rel data_11f045]  {\"xrealloc\"}",
    "xor     eax, eax  {0x0}",
    "mov     qword [rbp-0x70 {var_78}], rcx",
    "mov     dword [rbp-0x68 {var_70}], edx",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     qword [rel data_168ef8], rcx",
    "jmp     0xc5b2d",
    "mov     eax, dword [rdx]",
    "add     rdx, 0x20",
    "add     ebx, 0x1",
    "test    eax, eax",
    "jle     0xc5ef8",
    "test    r15d, r15d",
    "jne     0xc5ea8",
    "mov     ebx, 0xffffffff",
    "jmp     0xc5d55",
    "mov     rdx, qword [rbp-0x68 {var_70_1}]",
    "mov     rsi, qword [rbp-0x70 {var_78}]",
    "mov     edi, ebx",
    "call    sub_bc500",
    "test    eax, eax",
    "js      0xc5fbc",
    "test    r13, r13",
    "je      0xc6006",
    "call    __errno_location",
    "movsxd  rbx, ebx",
    "mov     edi, dword [rax]",
    "shl     rbx, 0x5",
    "call    strerror",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_12197f]  {\"%s: cannot get limit: %s\"}",
    "mov     r12, rax",
    "lea     rax, [rel data_154f00]",
    "mov     rbx, qword [rax+rbx+0x10]",
    "test    r13, r13",
    "jne     0xc5d7e",
    "mov     rdx, qword [rbp-0x68 {var_70_1}]",
    "mov     rsi, qword [rbp-0x70 {var_78}]",
    "mov     edi, ebx",
    "call    sub_bc500",
    "test    eax, eax",
    "js      0xc5fbc",
    "mov     rdx, qword [rbp-0x68 {var_70_1}]",
    "mov     rsi, qword [rbp-0x70 {var_78}]",
    "mov     edi, ebx",
    "call    sub_bc500",
    "test    eax, eax",
    "js      0xc5fbc",
    "mov     r13d, 0x1",
    "jmp     0xc5ada",
    "movzx   eax, byte [r13]",
    "cmp     al, 0x68",
    "je      0xc5f70",
    "mov     r10d, dword [rbp-0x8c {var_94_1}]",
    "test    r10d, r10d",
    "jne     0xc6019",
    "mov     rsi, qword [rbp-0x60 {rlimits_4}]",
    "jmp     0xc5edc",
    "lea     rsi, [rel data_1219aa]  {\"hard\"}",
    "mov     rdi, r13",
    "call    strcmp",
    "test    eax, eax",
    "jne     0xc5f30",
    "cmp     al, 0x73",
    "je      0xc5f96",
    "mov     rsi, qword [rbp-0x58 {rlimits_5}]",
    "xor     edx, edx  {0x0}",
    "cmp     r14d, 0x1",
    "mov     edi, ebx",
    "setg    dl",
    "call    sub_bc5b0",
    "jmp     0xc5e4a",
    "mov     rdi, r13",
    "call    sh_invalidnum",
    "mov     rdx, qword [rbp-0x58 {rlimits_5}]",
    "lea     r14, [rel data_154f00]",
    "movsxd  rbx, ebx",
    "jmp     0xc5dc3",
    "lea     rsi, [rel data_1219af]  {\"soft\"}",
    "mov     rdi, r13",
    "call    strcmp",
    "test    eax, eax",
    "jne     0xc5f30",
    "cmp     al, 0x75",
    "jne     0xc6184",
    "mov     r14d, dword [rel data_168ef0]",
    "add     r12, 0x1",
    "cmp     r14d, r12d",
    "jle     0xc6178",
    "mov     rax, rbx",
    "shl     rax, 0x5",
    "mov     r13d, dword [r14+rax+0x4]",
    "cmp     r13d, 0xff",
    "jg      0xc6241",
    "mov     rdx, qword [rbp-0x60 {rlimits_4}]",
    "lea     r14, [rel data_154f00]",
    "movsxd  rbx, ebx",
    "jmp     0xc5dc3",
    "test    al, al",
    "jne     0xc5f02",
    "lea     rsi, [rel data_121686]  {\"unlimited\"}",
    "mov     rdi, r13",
    "call    strcmp",
    "test    eax, eax",
    "jne     0xc5f30",
    "mov     r13d, dword [rbp-0x90 {var_98_1}]",
    "jmp     0xc5ada",
    "mov     rax, qword [rel data_168ef8]",
    "jmp     0xc5d20",
    "call    __errno_location",
    "mov     edi, 0x16",
    "mov     dword [rax], 0x16",
    "jmp     0xc6156",
    "lea     rsi, [rbp-0x50 {rlimits}]",
    "mov     edi, r13d",
    "mov     qword [rbp-0x80 {var_88_1}], rdx",
    "mov     qword [rbp-0x78 {var_80_1}], rsi {rlimits}",
    "call    getrlimit",
    "mov     rsi, qword [rbp-0x78 {var_80_1}]",
    "mov     rdx, qword [rbp-0x80 {var_88_1}]",
    "test    eax, eax",
    "js      0xc614f",
    "mov     rdx, r13",
    "jmp     0xc5f20",
    "nop     dword [rax]",
    "mov     rdx, 0xffffffffffffffff",
    "lea     r14, [rel data_154f00]",
    "movsxd  rbx, ebx",
    "mov     rdx, r12",
    "xor     ebx, ebx  {0x0}",
    "shl     rdx, 0x4",
    "add     rax, rdx",
    "lea     rdx, [rel data_154f20]",
    "mov     r13, qword [rax+0x8]",
    "mov     esi, dword [rax]",
    "mov     eax, 0x52",
    "jmp     0xc5d51",
    "call    strerror",
    "shl     rbx, 0x5",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_1219b4]  {\"%s: cannot modify limit: %s\"}",
    "mov     rbx, qword [r14+rbx+0x10]",
    "mov     r12, rax",
    "jmp     0xc5fea",
    "call    __errno_location",
    "mov     edi, dword [rax]",
    "lea     rax, [rel current_user]",
    "mov     r9d, dword [rax+0x4]  {data_1584a4}",
    "test    r9d, r9d",
    "je      0xc5e1a",
    "sub     eax, 0x30",
    "cmp     al, 0x9",
    "jbe     0xc5f10",
    "mul     rsi",
    "mov     rdx, rax",
    "jno     0xc5dc3",
    "lea     rdx, [rel posixly_correct]",
    "cmp     dword [rdx], 0x1  {posixly_correct}",
    "sbb     rsi, rsi",
    "and     esi, 0x200",
    "add     rsi, 0x200",
    "xor     edi, edi  {0x0}",
    "call    dcgettext",
    "mov     rdx, r12",
    "mov     rsi, rbx",
    "mov     rdi, rax",
    "xor     eax, eax  {0x0}",
    "call    builtin_error",
    "jmp     0xc5f38",
    "mov     ecx, dword [rbp-0x84 {var_8c_1}]",
    "test    ecx, ecx",
    "je      0xc5f60",
    "cmp     rdx, 0xffffffffffffffff",
    "je      0xc6124",
    "movzx   eax, byte [rdx+0x1]",
    "add     rdx, 0x1",
    "test    al, al",
    "je      0xc6190",
    "nop     word [rax+rax]",
    "xor     edi, edi  {0x0}",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_11f532[1]]  {\"limit\"}",
    "mov     qword [rbp-0x68 {var_70_3}], r13",
    "call    dcgettext",
    "mov     rdi, qword [rbp-0x68 {var_70_3}]",
    "mov     rsi, rax",
    "call    sh_erange",
    "jmp     0xc5f38",
    "mov     qword [rbp-0x48 {rlimits_1}], rdx",
    "jmp     0xc5e3a",
    "mov     eax, dword [rbp-0x88 {var_90_1}]",
    "mov     qword [rbp-0x50 {rlimits}], rdx",
    "test    eax, eax",
    "jne     0xc5f60",
    "mov     r8d, dword [rbp-0x88 {var_90_1}]",
    "test    r8d, r8d",
    "jne     0xc5f43",
    "mov     rdi, r13",
    "movsxd  rbx, ebx",
    "lea     r14, [rel data_154f00]",
    "call    string_to_rlimtype",
    "mov     rdx, rbx",
    "shl     rdx, 0x5",
    "movsxd  rsi, dword [r14+rdx+0x8]",
    "cmp     esi, 0xfffffffe",
    "jne     0xc61cd",
    "mov     edi, r13d",
    "call    setrlimit",
    "test    eax, eax",
    "js      0xc614f",
    "mov     edi, dword [rbp-0x84 {var_8c_1}]",
    "test    edi, edi",
    "je      0xc5f55",
    "mov     rax, qword [rbp-0x48 {rlimits_1}]",
    "cmp     rax, qword [rbp-0x50 {rlimits}]",
    "jae     0xc621e",
    "mov     rdx, 0xffffffffffffffff",
    "nop     dword [rax]",
    "mov     qword [rbp-0x50 {rlimits}], 0xffffffffffffffff",
    "mov     qword [rbp-0x50 {rlimits}], rax",
    "jmp     0xc5e3a",
    "mov     qword [rbp-0x50 {rlimits}], 0xffffffffffffffff",
    "jmp     0xc5e3a"
  ],
  "high level IL": [
    "void* fsbase",
    "int64_t rax = *(fsbase + 0x28)",
    "if (data_168f20 == 0)",
    "data_168f22 = 0x48",
    "void* const rcx_1 = &data_154f20",
    "void* rax_2 = &data_168f23",
    "data_168f20.w = 0x5361",
    "int32_t i = 0x52",
    "while (i s> 0)",
    "rcx_1 += 0x20",
    "*rax_2 = i.b",
    "rax_2 += 2",
    "i = *(rcx_1 - 0x20)",
    "*(rax_2 - 1) = 0x3b",
    "*rax_2 = 0",
    "if (data_168f00 == 0)",
    "data_168f00 = 0x10",
    "int64_t rax_11 = malloc(0x100)",
    "if (rax_11 == 0)",
    "sub_a7f00()",
    "noreturn",
    "data_168ef8 = rax_11",
    "int32_t r13 = 0",
    "int32_t r15 = 0",
    "data_168ef0 = 0",
    "__builtin_memset(&data_168d30, 0, 0x18)",
    "data_168d28 = 1",
    "while (true)",
    "int32_t rax_3 = internal_getopt(arg1, &data_168f20)",
    "int32_t var_78",
    "if (rax_3 == 0xffffffff)",
    "uint64_t loptend_1 = loptend",
    "int64_t rlimits_5",
    "int64_t rlimits",
    "if (r13 != 0)",
    "if (r15 == 0)",
    "r15 = 2",
    "char const (** const r12_4)[0x1c] = &data_154f10",
    "int32_t rbx_7 = 0",
    "int32_t i_1",
    "if (sub_bc500(rbx_7, &rlimits_5, &rlimits) == 0)",
    "int64_t rlimits_3",
    "if ((r15.b & 2) == 0)",
    "rlimits_3 = rlimits",
    "rlimits_3 = rlimits_5",
    "sub_bc5b0(rbx_7, rlimits_3, 1)",
    "int32_t errnum = *__errno_location()",
    "if (errnum != 0x16)",
    "strerror(errnum)",
    "*r12_4",
    "builtin_error(\"%s: cannot get limit: %s\", 0)",
    "i_1 = r12_4[2].d",
    "r12_4 = &r12_4[4]",
    "rbx_7 += 1",
    "do while (i_1 s> 0)",
    "*(fsbase + 0x28)",
    "if (rax == *(fsbase + 0x28))",
    "return sh_chkwrite(0) __tailcall",
    "break",
    "int64_t r14_2 = sx.q(data_168ef0)",
    "int32_t rax_14 = r14_2.d",
    "int32_t temp0_1 = r14_2.d",
    "int32_t* rdx_2",
    "if (temp0_1 == 0)",
    "rdx_2 = data_168ef8",
    "*rdx_2 = 0x66",
    "if (loptend_1 == 0)",
    "data_168ef0 = 1",
    "r14_2 = 1",
    "*(rdx_2 + 8) = 0",
    "int64_t* rax_28 = *(loptend_1 + 8)",
    "r14_2 = 1",
    "loptend_1 = *loptend_1",
    "data_168ef0 = 1",
    "*(rdx_2 + 8) = *rax_28",
    "goto label_c5c43",
    "int32_t* rcx_3",
    "if (temp0_1 s> 0)",
    "rdx_2 = data_168ef8",
    "label_c5c43:",
    "rcx_3 = rdx_2",
    "int32_t rsi_2 = 0",
    "label_c5c52:",
    "void* const r8_3 = &data_154f20",
    "int32_t i_2 = 0x52",
    "while (i_2 s> 0)",
    "if (*rcx_3 == i_2)",
    "rsi_2 += 1",
    "rcx_3 = &rcx_3[4]",
    "if (rsi_2 s< r14_2.d)",
    "goto label_c5c52",
    "if (loptend_1 == 0)",
    "goto label_c5cc3",
    "rax_14 = data_168ef0",
    "goto label_c5c8a",
    "i_2 = *r8_3",
    "r8_3 += 0x20",
    "builtin_error(dcgettext(nullptr, \"`%c': bad command\", 5), 0)",
    "r13 = 0x102",
    "if (loptend_1 != 0)",
    "label_c5c8a:",
    "rcx_3 = *(loptend_1 + 8)",
    "if (rcx_3 != 0)",
    "void* rdx_4 = data_168ef8 + (r14_2 << 4) - 0x10",
    "if (*(rdx_4 + 8) == 0)",
    "*(rdx_4 + 8) = *rcx_3",
    "rdx_2 = data_168ef8",
    "r14_2 = zx.q(rax_14)",
    "if (rax_14 s> 0)",
    "label_c5cc3:",
    "int32_t rax_15 = 2",
    "rcx_3.b = r15 == 0",
    "if (rcx_3.b == 0)",
    "rax_15 = r15",
    "int32_t rax_17 = 3",
    "if (rcx_3.b == 0)",
    "rax_17 = r15",
    "int64_t r12_2 = 0",
    "int32_t rax_18 = rax_17 & 1",
    "int32_t rdi_3 = rax_17 & 2",
    "int64_t* var_70_1 = &rlimits_5",
    "int64_t rlimits_4",
    "var_78.q = &rlimits_4",
    "int32_t* rax_19 = rdx_2",
    "while (true)",
    "int32_t rbx_2 = 0",
    "void* rax_20 = &rax_19[r12_2 * 4]",
    "void* const rdx_7 = &data_154f20",
    "char* r13_1 = *(rax_20 + 8)",
    "int32_t i_3 = 0x52",
    "while (*rax_20 != i_3)",
    "i_3 = *rdx_7",
    "rdx_7 += 0x20",
    "rbx_2 += 1",
    "if (i_3 s<= 0)",
    "rbx_2 = -1",
    "break",
    "int32_t rdx_11",
    "if (r15 != 0)",
    "char const* const msgid",
    "if (sub_bc500(rbx_2, var_78.q, var_70_1) s< 0)",
    "label_c5fd4:",
    "msgid = \"%s: cannot get limit: %s\"",
    "strerror(*__errno_location())",
    "(&data_154f10)[sx.q(rbx_2) * 4]",
    "label_c5ffc:",
    "builtin_error(dcgettext(nullptr, msgid, 5), 0)",
    "r13 = 1",
    "break",
    "if (r13_1 != 0)",
    "label_c5d7e:",
    "char i_4 = *r13_1",
    "int64_t rlimits_2",
    "int64_t rbx_3",
    "if (i_4 == 0x68)",
    "if (strcmp(r13_1, \"hard\") != 0)",
    "label_c5f33:",
    "sh_invalidnum(r13_1)",
    "r13 = 1",
    "break",
    "break",
    "rlimits_2 = rlimits_5",
    "rbx_3 = sx.q(rbx_2)",
    "if (i_4 == 0x73)",
    "if (strcmp(r13_1, \"soft\") != 0)",
    "goto label_c5f33",
    "rlimits_2 = rlimits_4",
    "rbx_3 = sx.q(rbx_2)",
    "if (i_4 != 0x75)",
    "if (i_4 != 0)",
    "char* rdx_12 = r13_1",
    "if (i_4 - 0x30 u> 9)",
    "goto label_c5f33",
    "i_4 = rdx_12[1]",
    "rdx_12 = &rdx_12[1]",
    "do while (i_4 != 0)",
    "rbx_3 = sx.q(rbx_2)",
    "int64_t rax_49 = string_to_rlimtype(r13_1)",
    "int64_t rsi_15 = sx.q(*((rbx_3 << 5) + 0x154f08))",
    "if (rsi_15.d == 0xfffffffe)",
    "rsi_15 = (zx.q((sbb.q(rsi_15, rsi_15, posixly_correct u< 1)).d) & 0x200) + 0x200",
    "int64_t rlimits_6",
    "int64_t rdx_20",
    "rdx_20:rlimits_6 = mulu.dp.q(rax_49, rsi_15)",
    "rlimits_2 = rlimits_6",
    "if (mulu.dp.q(rax_49, rsi_15) u>> 0x40 != zx.o(0))",
    "sh_erange(r13_1, dcgettext(nullptr, \"limit\", 5))",
    "r13 = 1",
    "break",
    "break",
    "if (strcmp(r13_1, \"unlimited\") != 0)",
    "goto label_c5f33",
    "rlimits_2 = -1",
    "rbx_3 = sx.q(rbx_2)",
    "enum __rlimit_resource resource = *((rbx_3 << 5) + 0x154f04)",
    "int32_t errnum_1",
    "if (resource s> 0xff)",
    "errnum_1 = 0x16",
    "*__errno_location() = 0x16",
    "label_c6156:",
    "strerror(errnum_1)",
    "msgid = \"%s: cannot modify limit: %s\"",
    "(&data_154f10)[rbx_3 * 4]",
    "goto label_c5ffc",
    "int32_t rax_25 = getrlimit(resource, &rlimits)",
    "int32_t rax_27",
    "if (rax_25 s>= 0)",
    "int64_t rlimits_1",
    "if (data_1584a4 == 0 || rlimits_2 != -1)",
    "if (rdi_3 == 0)",
    "rlimits_1 = rlimits_2",
    "rlimits = rlimits_2",
    "if (rax_18 != 0)",
    "rlimits_1 = rlimits_2",
    "if (rax_18 != 0)",
    "if (rdi_3 != 0)",
    "rlimits = -1",
    "rlimits_1 = -1",
    "if (rlimits_1 u>= rlimits)",
    "rlimits = rlimits_1",
    "rlimits = -1",
    "rax_27 = setrlimit(resource, &rlimits)",
    "if (rax_25 s< 0 || rax_27 s< 0)",
    "errnum_1 = *__errno_location()",
    "goto label_c6156",
    "if ((rax_15 & 2) != 0)",
    "goto label_c6019",
    "rdx_11.b = r14_2.d s> 1",
    "sub_bc5b0(rbx_2, rlimits_5, rdx_11)",
    "if (r13_1 != 0)",
    "if (sub_bc500(rbx_2, var_78.q, var_70_1) s< 0)",
    "goto label_c5fd4",
    "goto label_c5d7e",
    "if (sub_bc500(rbx_2, var_78.q, var_70_1) s< 0)",
    "goto label_c5fd4",
    "label_c6019:",
    "rdx_11.b = r14_2.d s> 1",
    "sub_bc5b0(rbx_2, rlimits_4, rdx_11)",
    "r14_2 = zx.q(data_168ef0)",
    "r12_2 += 1",
    "if (r14_2.d s<= r12_2.d)",
    "break",
    "rax_19 = data_168ef8",
    "if (rax_3 == 0x48)",
    "r15 |= 1",
    "continue",
    "if (rax_3 s> 0x48)",
    "if (rax_3 == 0x53)",
    "r15 |= 2",
    "continue",
    "if (rax_3 == 0x61)",
    "r13 += 1",
    "continue",
    "goto label_c5b10",
    "if (rax_3 == 0xffffff9d)",
    "builtin_help()",
    "if (rax_3 != 0x3f)",
    "label_c5b10:",
    "int32_t r8_1 = data_168ef0",
    "int32_t rax_7 = data_168f00",
    "void* oldmem = data_168ef8",
    "if (r8_1 s>= rax_7)",
    "int32_t rax_12 = rax_7 * 2",
    "data_168f00 = rax_12",
    "int64_t bytes = sx.q(rax_12) << 4",
    "if (oldmem == 0)",
    "oldmem = malloc(bytes)",
    "oldmem = realloc(oldmem, bytes)",
    "if (oldmem == 0)",
    "var_78.q = oldmem",
    "int32_t var_70 = rax_3",
    "sub_a7f00()",
    "noreturn",
    "data_168ef8 = oldmem",
    "data_168ef0 = r8_1 + 1",
    "int32_t* rcx_2 = oldmem + (sx.q(r8_1) << 4)",
    "*rcx_2 = rax_3",
    "*(rcx_2 + 8) = list_optarg",
    "continue",
    "builtin_usage()",
    "r13 = 0x102",
    "*(fsbase + 0x28)",
    "if (rax == *(fsbase + 0x28))",
    "return zx.q(r13)",
    "break",
    "__stack_chk_fail()",
    "noreturn"
  ]
}