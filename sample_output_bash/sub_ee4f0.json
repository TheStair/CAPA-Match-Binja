{
  "address": "0xee4f0",
  "rules": [
    "populate SysWhispers2 syscall list/074b321f7b7941958bfc8de4f583b5b2",
    "empty recycle bin quietly/7589c2299aa24b91b43483b27cb1b2e1",
    "connect to WMI namespace via WbemLocator/472165133b624c67bbc5d17c3915a018",
    "check Internet connectivity via WinINet/4ebebc1fd30e4dc8aec0393f85edc8f3",
    "contain loop",
    "64-bit execution via heavens gate/60cabeb435b14393adc864c969c82de8",
    "check OS version/35d8fd86b2bf418898b01c7af02eb9bc",
    "enumerate PE sections/6daf36d0aacf4abd837ad173c20584ec/cb6a026a778247b1a261c9e375dba739",
    "check OS version/a792de506c61438eae0e98a59003db67",
    "write file on Windows/dbc9cc37967145a499adfa89f5005055",
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a",
    "check for time delay via GetTickCount/173be9e5d4d440c09f85224fcb793b6a"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "push    r14 {__saved_r14}",
    "push    r13 {__saved_r13}",
    "push    r12 {__saved_r12}",
    "push    rbx {__saved_rbx}",
    "mov     rbx, rdi",
    "sub     rsp, 0x38",
    "mov     r14d, dword [rel data_16a84c]",
    "mov     r12d, dword [rel data_16a848]",
    "mov     rax, qword [fs:0x28]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "xor     eax, eax  {0x0}",
    "mov     rdx, qword [rel data_16a840]",
    "lea     r13d, [r14+0x1]",
    "cmp     r13d, r12d",
    "jl      0xee56a",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "movsxd  rcx, r14d",
    "mov     dword [rel data_16a84c], r13d",
    "movzx   r15d, byte [rax]  {_rl_parsing_conditionalized_out}",
    "mov     byte [rdx+rcx], r15b",
    "test    r15b, r15b",
    "jne     0xee64a",
    "test    rdx, rdx",
    "je      0xee920",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "sub     rax, qword [fs:0x28]",
    "jne     0xeed9a",
    "mov     rdi, rbx",
    "call    strlen",
    "mov     dword [rbp-0x3c {var_44}], 0x0",
    "mov     rdx, rbx",
    "xor     ecx, ecx  {0x0}",
    "mov     r12, rax",
    "movzx   eax, byte [rbx]",
    "test    al, al",
    "je      0xee5d2",
    "mov     dword [rel data_16a848], 0x14",
    "mov     edi, 0x14",
    "call    malloc",
    "mov     rdx, rax",
    "test    rax, rax",
    "jne     0xee563",
    "add     r12d, 0x14",
    "mov     rdi, rdx",
    "mov     dword [rel data_16a848], r12d",
    "movsxd  r12, r12d",
    "mov     rsi, r12",
    "call    realloc",
    "mov     rdx, rax",
    "test    rax, rax",
    "je      0xeed9f",
    "call    __stack_chk_fail",
    "{ Does not return }",
    "add     rsp, 0x38",
    "xor     eax, eax  {0x0}",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "lea     rax, [rel rl_terminal_name]",
    "mov     r13, qword [rax]  {rl_terminal_name}",
    "test    r13, r13",
    "je      0xee5fd",
    "nop     word [rax+rax]",
    "mov     qword [rel data_16a840], rdx",
    "mov     qword [rbp-0x58 {oldmem_3}], rax",
    "mov     esi, 0x14",
    "lea     rdi, [rel data_11f01e]  {\"xmalloc\"}",
    "jmp     0xeedad",
    "mov     qword [rbp-0x58 {oldmem_4}], rax",
    "mov     rsi, r12",
    "lea     rdi, [rel data_11f045]  {\"xrealloc\"}",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_1229c1]  {\"mode=\"}",
    "mov     rdi, rbx",
    "call    strncasecmp",
    "test    eax, eax",
    "jne     0xee670",
    "mov     edx, 0x5",
    "lea     rsi, [rel data_1229bb]  {\"term=\"}",
    "mov     rdi, rbx",
    "call    strncasecmp",
    "test    eax, eax",
    "je      0xee890",
    "lea     rax, [rel rl_terminal_name]",
    "mov     byte [rdx], 0x0",
    "mov     dword [rbp-0x3c {var_44}], ecx",
    "mov     r13, qword [rax]  {rl_terminal_name}",
    "test    r13, r13",
    "jne     0xee5e1",
    "cmp     al, 0x9",
    "je      0xee870",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     edx, 0x7",
    "lea     rsi, [rel data_1222d3[0xd]]  {\"version\"}",
    "mov     rdi, rbx",
    "call    strncasecmp",
    "mov     r8d, eax",
    "test    eax, eax",
    "jne     0xee970",
    "add     rbx, 0x5",
    "lea     rsi, [rel data_11f280]  {\"emacs\"}",
    "mov     rdi, rbx",
    "call    strcasecmp",
    "mov     edx, eax",
    "mov     eax, 0x1",
    "test    edx, edx",
    "jne     0xee958",
    "mov     rdi, r13",
    "call    strlen",
    "lea     r12, [rax+0x1]",
    "mov     rdi, r12",
    "call    malloc",
    "mov     r14, rax",
    "test    rax, rax",
    "je      0xeedc8",
    "jmp     0xee5fd",
    "movzx   eax, byte [rdx+0x1]",
    "add     rdx, 0x1",
    "test    al, al",
    "jne     0xee5b0",
    "lea     rax, [rel rl_readline_name]",
    "mov     rdi, rbx",
    "mov     rsi, qword [rax]  {rl_readline_name}",
    "call    strcasecmp",
    "test    eax, eax",
    "jne     0xee998",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "mov     byte [rax], 0x1  {_rl_parsing_conditionalized_out}",
    "movsxd  rax, dword [rbp-0x3c {var_44}]",
    "test    eax, eax",
    "jle     0xee6b4",
    "lea     rsi, [rel data_120c31]  {\"vi\"}",
    "mov     rdi, rbx",
    "call    strcasecmp",
    "neg     eax",
    "sbb     eax, eax",
    "jmp     0xee637",
    "lea     rdx, [rel rl_editing_mode]",
    "cmp     dword [rdx], eax",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "setne   byte [rax]  {_rl_parsing_conditionalized_out}",
    "mov     rsi, r12",
    "lea     rdi, [rel data_11f01e]  {\"xmalloc\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "mov     rdx, r12",
    "mov     rsi, r13",
    "mov     rdi, r14",
    "mov     r12, r14",
    "call    __strcpy_chk",
    "mov     esi, 0x2d",
    "mov     rdi, r14",
    "call    strchr",
    "test    rax, rax",
    "je      0xee8d6",
    "add     ecx, 0x1",
    "cmp     al, 0x20",
    "je      0xee870",
    "mov     dword [rbp-0x3c {var_44}], ecx",
    "lea     r14, [rel data_156f58]",
    "xor     r15d, r15d  {0x0}",
    "lea     rsi, [rel data_122981]  {\"bind-tty-special-chars\"}",
    "jmp     0xee9c4",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "mov     byte [rax], 0x0  {_rl_parsing_conditionalized_out}",
    "jmp     0xee64a",
    "movsxd  r12, r12d",
    "mov     dword [rbp-0x3c {var_44}], 0x7",
    "mov     byte [rbx+r12], 0x0",
    "movzx   eax, byte [rbx+0x7]",
    "cmp     al, 0x20",
    "je      0xee6d3",
    "cmp     eax, r12d",
    "jg      0xee6b4",
    "add     rbx, 0x5",
    "mov     rsi, r12",
    "mov     rdi, rbx",
    "call    strcasecmp",
    "test    eax, eax",
    "je      0xee901",
    "mov     byte [rax], 0x0",
    "mov     rdi, rbx",
    "call    strcasecmp",
    "test    eax, eax",
    "jne     0xee9b0",
    "lea     rcx, [rbx+0x8]",
    "mov     rdx, rcx",
    "nop     word [rax+rax]",
    "lea     r9, [rbx+0x7]",
    "cmp     al, 0x9",
    "jne     0xee6fd",
    "lea     rax, [rbx+rax-0x1]",
    "cmp     byte [rax], 0x0",
    "je      0xeea81",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "mov     rdi, r12",
    "mov     byte [rax], r15b  {_rl_parsing_conditionalized_out}",
    "call    free",
    "jmp     0xee64a",
    "lea     rax, [rel rl_terminal_name]",
    "mov     rdi, rbx",
    "mov     rsi, qword [rax]  {rl_terminal_name}",
    "call    strcasecmp",
    "test    eax, eax",
    "setne   r15b",
    "mov     rsi, qword [r14]",
    "add     r14, 0x18",
    "add     r15d, 0x1",
    "test    rsi, rsi",
    "je      0xeec33",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "movsxd  r15, r15d",
    "lea     rdx, [r15+r15*2]",
    "mov     byte [rax], 0x1  {_rl_parsing_conditionalized_out}",
    "lea     rax, [rel data_156f40]",
    "mov     r14, qword [rax+rdx*8]",
    "movzx   eax, byte [rdx]",
    "mov     r9, rdx",
    "lea     rdx, [rdx+0x1]",
    "cmp     al, 0x20",
    "je      0xee6e0",
    "cmp     al, 0x9",
    "je      0xee6e0",
    "lea     edx, [rax-0x3c]",
    "cmp     dl, 0x2",
    "jbe     0xee70d",
    "mov     byte [rax], 0x20",
    "jmp     0xee6b4",
    "lea     r15, [rel data_155638]",
    "xor     r14d, r14d  {0x0}",
    "lea     rsi, [rel data_122998]  {\"active-region-end-color\"}",
    "jmp     0xeec64",
    "movsxd  rdx, ecx",
    "movsxd  r12, r12d",
    "mov     dword [rbp-0x3c {var_44}], ecx",
    "lea     r8, [rbx+rdx]",
    "mov     byte [rbx+r12], 0x0",
    "movzx   eax, byte [r8]",
    "cmp     al, 0x20",
    "je      0xeea26",
    "test    eax, eax",
    "jg      0xeed15",
    "mov     edx, r9d",
    "sub     edx, ecx",
    "add     edx, 0x8",
    "mov     dword [rbp-0x3c {var_44}], edx",
    "mov     rdi, rbx",
    "lea     rsi, [rbp-0x3c {var_44}]",
    "xor     eax, eax  {0x0}",
    "call    sub_eaee0",
    "mov     edi, eax",
    "test    edi, edi",
    "jle     0xeed2b",
    "cmp     al, 0x21",
    "jne     0xeea89",
    "mov     rdi, rbx",
    "call    strcasecmp",
    "test    eax, eax",
    "jne     0xeec50",
    "lea     rsi, [rbx+rdx+0x1]",
    "mov     rdx, rsi",
    "nop     ",
    "cmp     al, 0x9",
    "jne     0xeea4e",
    "lea     rax, [rbx+rax-0x1]",
    "cmp     byte [rax], 0x0",
    "jne     0xeea08",
    "mov     rsi, r9",
    "lea     rdi, [rel data_134738]  {\"comparison operator expected, fo\u2026\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_eb6a0",
    "jmp     0xee64a",
    "movsxd  rax, dword [rbp-0x3c {var_44}]",
    "lea     rsi, [rbx+rax]",
    "mov     r9, rax",
    "movzx   edx, byte [rsi]",
    "test    dl, dl",
    "je      0xeed02",
    "test    al, al",
    "lea     rax, [rel data_122350]",
    "lea     rdi, [rel data_134738]  {\"comparison operator expected, fo\u2026\"}",
    "cmove   r9, rax  {data_122350, \"end-of-line\"}",
    "xor     eax, eax  {0x0}",
    "mov     rsi, r9",
    "call    sub_eb6a0",
    "jmp     0xee64a",
    "mov     rsi, qword [r15]",
    "add     r15, 0x18",
    "add     r14d, 0x1",
    "test    rsi, rsi",
    "je      0xeed41",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "movsxd  r14, r14d",
    "lea     rdx, [r14+r14*2]",
    "mov     byte [rax], 0x1  {_rl_parsing_conditionalized_out}",
    "lea     rax, [rel data_155620]",
    "mov     r14, qword [rax+rdx*8]",
    "jmp     0xee9ec",
    "movzx   eax, byte [rdx]",
    "mov     r8, rdx",
    "lea     rdx, [rdx+0x1]",
    "cmp     al, 0x20",
    "je      0xeea30",
    "cmp     al, 0x9",
    "je      0xeea30",
    "cmp     al, 0x3d",
    "je      0xeeb2b",
    "mov     byte [rax], 0x20",
    "jmp     0xeea08",
    "lea     rdi, [rel data_134768]  {\"numeric argument expected, found\u2026\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_eb6a0",
    "jmp     0xee64a",
    "lea     rcx, [rbx+rax+0x1]",
    "add     r9d, 0x1",
    "mov     r13d, dword [rbp-0x48 {var_50}]",
    "xor     eax, eax  {0x0}",
    "mov     r11, rcx",
    "sub     r9d, esi",
    "sub     r11, rsi",
    "jmp     0xee76e",
    "lea     rax, [rel _rl_parsing_conditionalized_out]",
    "mov     byte [rax], 0x1  {_rl_parsing_conditionalized_out}",
    "jmp     0xee64a",
    "mov     rdi, r14",
    "call    strlen",
    "mov     rcx, rax",
    "movsxd  rax, dword [rbp-0x3c {var_44}]",
    "cmp     eax, r12d",
    "jg      0xeea08",
    "add     ecx, 0x1",
    "sub     ecx, esi",
    "lea     edx, [rcx+r8]",
    "mov     dword [rbp-0x3c {var_44}], edx",
    "lea     rsi, [rbp-0x3c {var_44}]",
    "mov     rdi, rbx",
    "xor     eax, eax  {0x0}",
    "call    sub_eaee0",
    "mov     r15d, eax",
    "lea     eax, [rax-0x1]",
    "cmp     eax, 0x1",
    "ja      0xeed50",
    "cmp     al, 0x21",
    "je      0xeeb2b",
    "cmp     dl, 0x20",
    "mov     r10d, eax",
    "sete    al",
    "cmp     dl, 0x9",
    "sete    r12b",
    "or      al, r12b",
    "jne     0xee758",
    "mov     rsi, r8",
    "lea     rdi, [rel data_1347b0]  {\"equality comparison operator exp\u2026\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_eb6a0",
    "jmp     0xee64a",
    "movsxd  rax, dword [rbp-0x3c {var_44}]",
    "lea     r12, [rbx+rax]",
    "mov     r9, rax",
    "movzx   edx, byte [r12]",
    "test    dl, dl",
    "je      0xeed7c",
    "test    al, al",
    "lea     rax, [rel data_122350]",
    "lea     rdi, [rel data_1347b0]  {\"equality comparison operator exp\u2026\"}",
    "cmove   r8, rax  {data_122350, \"end-of-line\"}",
    "xor     eax, eax  {0x0}",
    "mov     rsi, r8",
    "call    sub_eb6a0",
    "jmp     0xee64a",
    "movzx   edx, byte [rcx]",
    "lea     r13d, [r9+rsi]",
    "add     rcx, 0x1",
    "add     rsi, r11",
    "test    dl, dl",
    "je      0xeed02",
    "test    r10b, r10b",
    "je      0xee78c",
    "mov     rsi, r12",
    "lea     rdi, [rel data_1229c7]  {\"argument expected, found `%s'\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_eb6a0",
    "jmp     0xee64a",
    "lea     rcx, [rbx+rax+0x1]",
    "lea     esi, [r9+0x1]",
    "mov     r10d, dword [rbp-0x50 {var_58}]",
    "xor     eax, eax  {0x0}",
    "mov     r8, rcx",
    "sub     esi, r12d",
    "sub     r8, r12",
    "jmp     0xeeb96",
    "sub     edx, 0x30",
    "cmp     dl, 0x9",
    "ja      0xeed02",
    "mov     dword [rbp-0x3c {var_44}], r13d",
    "cmp     dl, 0x20",
    "mov     edi, eax",
    "sete    al",
    "cmp     dl, 0x9",
    "sete    dl",
    "or      al, dl",
    "jne     0xeeb80",
    "movsxd  r11, dword [rbp-0x3c {var_44}]",
    "xor     r9d, r9d  {0x0}",
    "movzx   edx, byte [rbx+r11]",
    "lea     ecx, [r11+0x1]",
    "mov     r10, r11",
    "movsxd  rcx, ecx",
    "lea     r12d, [rdx-0x30]",
    "cmp     r12b, 0x9",
    "ja      0xee7ea",
    "movzx   edx, byte [rcx]",
    "lea     r10d, [rsi+r12]",
    "add     rcx, 0x1",
    "add     r12, r8",
    "test    dl, dl",
    "je      0xeed7c",
    "test    dil, dil",
    "je      0xeebb4",
    "cmp     dl, 0x2e",
    "je      0xeec91",
    "nop     dword [rax+rax]",
    "lea     rdx, [rbx+r9]",
    "movzx   ecx, byte [rdx]",
    "test    cl, cl",
    "je      0xeed92",
    "mov     dword [rbp-0x3c {var_44}], r10d",
    "movsxd  r9, r10d",
    "movzx   edx, byte [rbx+r11+0x1]",
    "lea     ecx, [rdx-0x30]",
    "cmp     cl, 0x9",
    "jbe     0xeeca3",
    "movsxd  rsi, dword [rbp-0x3c {var_44}]",
    "mov     rdx, rsi",
    "add     rsi, rbx",
    "movzx   ecx, byte [rsi]",
    "sub     edx, 0x30",
    "lea     r9d, [r9+r9*4]",
    "mov     r11, rcx",
    "movsx   edx, dl",
    "lea     r9d, [rdx+r9*2]",
    "movzx   edx, byte [rbx+rcx]",
    "lea     rcx, [rcx+0x1]",
    "lea     r10d, [rdx-0x30]",
    "cmp     r10b, 0x9",
    "jbe     0xee7c0",
    "mov     dword [rbp-0x3c {var_44}], r11d",
    "mov     r10d, r11d",
    "mov     rbx, rdx",
    "jmp     0xeebf0",
    "lea     rax, [rbx+r9+0x1]",
    "mov     rbx, rdx",
    "mov     rdx, rax",
    "sub     rdx, rbx",
    "nop     dword [rax]",
    "lea     edx, [r10+0x1]",
    "movsxd  rsi, edx",
    "mov     dword [rbp-0x3c {var_44}], edx",
    "add     rsi, rbx",
    "movzx   ecx, byte [rsi]",
    "lea     r11d, [rcx-0x30]",
    "cmp     r11b, 0x9",
    "ja      0xee800",
    "test    dl, dl",
    "jne     0xeed02",
    "cmp     cl, 0x20",
    "mov     r11d, eax",
    "sete    al",
    "cmp     cl, 0x9",
    "sete    r10b",
    "or      al, r10b",
    "jne     0xee818",
    "jmp     0xeeaac",
    "mov     byte [rbx], 0x0",
    "mov     rdi, r14",
    "mov     byte [rbp-0x44 {var_4c_1}], cl",
    "call    rl_variable_value",
    "cmp     r15d, 0x1",
    "movzx   ecx, byte [rbp-0x44 {var_4c_1}]",
    "mov     rdi, rax",
    "je      0xeed66",
    "cmp     cl, 0x9",
    "je      0xeebf0",
    "add     edx, 0x1",
    "mov     r12d, dword [rbp-0x4c {var_54}]",
    "movsxd  rdx, edx",
    "test    cl, cl",
    "jne     0xee82c",
    "lea     edx, [r10+0x2]",
    "movsxd  rdx, edx",
    "nop     dword [rax+rax]",
    "mov     r12d, edx",
    "add     rdx, 0x1",
    "movzx   ecx, byte [rbx+rdx-0x1]",
    "test    cl, cl",
    "je      0xeeaac",
    "test    r11b, r11b",
    "je      0xee84a",
    "lea     eax, [r9+r9*4]",
    "lea     ecx, [r8+rax*2]",
    "cmp     edi, 0x6",
    "ja      0xeead5",
    "mov     rsi, r12",
    "call    strcasecmp",
    "movzx   ecx, byte [rbp-0x44 {var_4c_1}]",
    "test    eax, eax",
    "setne   al",
    "jmp     0xeec23",
    "mov     rsi, r12",
    "mov     byte [rbp-0x44 {var_4c_2}], cl",
    "call    strcasecmp",
    "movzx   ecx, byte [rbp-0x44 {var_4c_2}]",
    "test    eax, eax",
    "sete    al",
    "movzx   ecx, byte [rax]",
    "add     rax, 0x1",
    "add     rbx, rdx",
    "test    cl, cl",
    "jne     0xeebd8",
    "sub     ecx, 0x30",
    "lea     esi, [r8+r8*4]",
    "mov     r10, rdx",
    "movsx   ecx, cl",
    "lea     r8d, [rcx+rsi*2]",
    "movzx   ecx, byte [rbx+rdx]",
    "add     rdx, 0x1",
    "lea     esi, [rcx-0x30]",
    "cmp     sil, 0x9",
    "jbe     0xeecd0",
    "mov     dword [rbp-0x3c {var_44}], r10d",
    "mov     edx, r10d",
    "lea     rsi, [rbx+r10]",
    "jmp     0xee800",
    "cmp     cl, 0x23",
    "je      0xeeaac",
    "mov     dword [rbp-0x3c {var_44}], r12d",
    "{Case 0x0}",
    "movzx   eax, byte [rbp-0x44 {var_4c}]",
    "lea     rdi, [rel _rl_parsing_conditionalized_out]",
    "xor     eax, 0x1",
    "mov     byte [rdi], al  {_rl_parsing_conditionalized_out}",
    "jmp     0xee64a",
    "lea     rdx, [rel jump_table_138af4]",
    "movsxd  rax, dword [rdx+rdi*4]",
    "add     rax, rdx",
    "jmp     rax",
    "lea     rdi, [rel _rl_parsing_conditionalized_out]",
    "mov     byte [rdi], al  {_rl_parsing_conditionalized_out}",
    "mov     byte [rbx], cl",
    "jmp     0xee64a",
    "cmp     cl, 0x20",
    "je      0xeebf0",
    "lea     rdi, [rel data_134790]  {\"trailing garbage on line: `%s'\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_eb6a0",
    "jmp     0xee64a",
    "{Case 0x6}",
    "xor     eax, eax  {0x0}",
    "cmp     ecx, 0x51",
    "setg    al",
    "mov     dword [rbp-0x44 {var_4c}], eax",
    "{Case 0x5}",
    "xor     eax, eax  {0x0}",
    "cmp     ecx, 0x52",
    "setg    al",
    "mov     dword [rbp-0x44 {var_4c}], eax",
    "jmp     0xeead5",
    "{Case 0x4}",
    "xor     eax, eax  {0x0}",
    "cmp     ecx, 0x52",
    "setle   al",
    "mov     dword [rbp-0x44 {var_4c}], eax",
    "jmp     0xeead5",
    "{Case 0x1}",
    "xor     eax, eax  {0x0}",
    "cmp     ecx, 0x52",
    "sete    al",
    "mov     dword [rbp-0x44 {var_4c}], eax",
    "jmp     0xeead5",
    "{Case 0x3}",
    "xor     eax, eax  {0x0}",
    "cmp     ecx, 0x51",
    "setle   al",
    "mov     dword [rbp-0x44 {var_4c}], eax",
    "jmp     0xeead5",
    "{Case 0x2}",
    "xor     eax, eax  {0x0}",
    "cmp     ecx, 0x52",
    "setne   al",
    "mov     dword [rbp-0x44 {var_4c}], eax",
    "jmp     0xeead5"
  ],
  "high level IL": [
    "int32_t r14 = data_16a84c",
    "int32_t r12 = data_16a848",
    "void* fsbase",
    "int64_t rax = *(fsbase + 0x28)",
    "char* oldmem = data_16a840",
    "if (r14 + 1 s>= r12)",
    "if (oldmem == 0)",
    "data_16a848 = 0x14",
    "char* oldmem_2 = malloc(0x14)",
    "oldmem = oldmem_2",
    "if (oldmem_2 == 0)",
    "char* oldmem_3 = oldmem_2",
    "sub_a7f00()",
    "noreturn",
    "data_16a848 = r12 + 0x14",
    "char* oldmem_1 = realloc(oldmem, sx.q(r12 + 0x14))",
    "oldmem = oldmem_1",
    "if (oldmem_1 == 0)",
    "char* oldmem_4 = oldmem_1",
    "sub_a7f00()",
    "noreturn",
    "data_16a840 = oldmem",
    "data_16a84c = r14 + 1",
    "uint8_t _rl_parsing_conditionalized_out_1 = _rl_parsing_conditionalized_out",
    "oldmem[sx.q(r14)] = _rl_parsing_conditionalized_out_1",
    "if (_rl_parsing_conditionalized_out_1 == 0)",
    "int32_t rax_2 = strlen(arg1)",
    "int32_t var_44 = 0",
    "char* rdx = arg1",
    "int32_t rcx_1 = 0",
    "char rax_3 = *arg1",
    "uint64_t rl_terminal_name_1",
    "if (rax_3 != 0)",
    "while (true)",
    "rcx_1 += 1",
    "if (rax_3 == 0x20 || rax_3 == 9)",
    "*rdx = 0",
    "var_44 = rcx_1",
    "rl_terminal_name_1 = rl_terminal_name",
    "if (rl_terminal_name_1 != 0)",
    "goto label_ee5f0",
    "goto label_ee60c",
    "rax_3 = rdx[1]",
    "rdx = &rdx[1]",
    "if (rax_3 != 0)",
    "continue",
    "var_44 = rcx_1",
    "break",
    "rl_terminal_name_1 = rl_terminal_name",
    "if (rl_terminal_name_1 == 0)",
    "label_ee60c:",
    "if (strncasecmp(arg1, \"mode=\", 5) != 0)",
    "int32_t rax_11 = strncasecmp(arg1, \"version\", 7)",
    "uint64_t r8_1 = zx.q(rax_11)",
    "if (rax_11 != 0)",
    "if (strcasecmp(arg1, rl_readline_name) != 0)",
    "char const (** const r14_2)[0x15] = &data_156f58",
    "int32_t r15 = 0",
    "char const (* rsi_11)[0x15] = \"bind-tty-special-chars\"",
    "while (true)",
    "char* r14_3",
    "if (strcasecmp(arg1, rsi_11) == 0)",
    "_rl_parsing_conditionalized_out = 1",
    "r14_3 = (&data_156f40)[sx.q(r15) * 3]",
    "label_ee9ef:",
    "int32_t rax_28 = strlen(r14_3)",
    "int64_t rax_29 = sx.q(var_44)",
    "if (rax_29.d s<= rax_2 && rax_29.d s> 0 && arg1[rax_29 - 1] == 0)",
    "arg1[rax_29 - 1] = 0x20",
    "int64_t rdx_17 = sx.q(rax_28)",
    "var_44 = rax_28",
    "arg1[sx.q(rax_2)] = 0",
    "char rax_30 = arg1[rdx_17]",
    "if (rax_30 == 0x20 || rax_30 == 9)",
    "void* rdx_18 = &arg1[rdx_17 + 1]",
    "void* r8_2",
    "while (true)",
    "rax_30 = *rdx_18",
    "r8_2 = rdx_18",
    "rdx_18 += 1",
    "if (rax_30 != 0x20)",
    "if (rax_30 != 9)",
    "break",
    "var_44 = rax_28 + 1 - (&arg1[rdx_17 + 1]).d + r8_2.d",
    "if (rax_30 == 0x3d || rax_30 == 0x21)",
    "int32_t rax_43 = sub_eaee0(arg1, &var_44)",
    "if (rax_43 - 1 u> 1)",
    "sub_eb6a0(\"equality comparison operator exp\u2026\", 0)",
    "int64_t rax_45 = sx.q(var_44)",
    "void* r12_10 = &arg1[rax_45]",
    "int64_t r9_7 = rax_45",
    "bool rdx_20 = *r12_10",
    "if (rdx_20 == 0)",
    "label_eed88:",
    "sub_eb6a0(\"argument expected, found `%s'\", 0)",
    "void* rcx_11 = &arg1[rax_45 + 1]",
    "int32_t var_58",
    "int32_t r10_4 = var_58",
    "bool rax_46 = false",
    "int32_t rsi_17 = (r9_7 + 1).d - r12_10.d",
    "void* r8_4 = rcx_11 - r12_10",
    "while (true)",
    "bool rdi_21 = rax_46",
    "rax_46 = rdx_20 == 0x20 | rdx_20 == 9",
    "if (rax_46 == 0)",
    "if (rdi_21 != 0)",
    "var_44 = r10_4",
    "r9_7 = sx.q(r10_4)",
    "void* rdx_21 = &arg1[r9_7]",
    "char i = *rdx_21",
    "void* rbx_3",
    "if (i == 0)",
    "rbx_3 = rdx_21",
    "void* rax_47 = &arg1[r9_7 + 1]",
    "rbx_3 = rdx_21",
    "void* rdx_23 = rax_47 - rbx_3",
    "while (i != 0x20)",
    "if (i == 9)",
    "break",
    "i = *rax_47",
    "rax_47 += 1",
    "rbx_3 += rdx_23",
    "if (i == 0)",
    "break",
    "*rbx_3 = 0",
    "char* rax_48 = rl_variable_value(r14_3)",
    "int32_t rax_49",
    "char i_2",
    "if (rax_43 == 1)",
    "i_2 = i",
    "rax_49.b = strcasecmp(rax_48, r12_10) != 0",
    "i_2 = i",
    "rax_49.b = strcasecmp(rax_48, r12_10) == 0",
    "_rl_parsing_conditionalized_out = rax_49.b",
    "*rbx_3 = i_2",
    "break",
    "rdx_20 = *rcx_11",
    "r10_4 = rsi_17 + r12_10.d",
    "rcx_11 += 1",
    "r12_10 += r8_4",
    "if (rdx_20 == 0)",
    "goto label_eed88",
    "sub_eb6a0(\"equality comparison operator exp\u2026\", 0)",
    "break",
    "rsi_11 = *r14_2",
    "r14_2 = &r14_2[3]",
    "r15 += 1",
    "if (rsi_11 == 0)",
    "char** r15_3 = &data_155638",
    "int32_t r14_4 = 0",
    "char* i_1 = \"active-region-end-color\"",
    "while (i_1 != 0)",
    "if (strcasecmp(arg1, i_1) == 0)",
    "_rl_parsing_conditionalized_out = 1",
    "r14_3 = (&data_155620)[sx.q(r14_4) * 3]",
    "goto label_ee9ef",
    "i_1 = *r15_3",
    "r15_3 = &r15_3[3]",
    "r14_4 += 1",
    "_rl_parsing_conditionalized_out = 1",
    "break",
    "_rl_parsing_conditionalized_out = 0",
    "_rl_parsing_conditionalized_out = 1",
    "int64_t rax_12 = sx.q(var_44)",
    "if (rax_12.d s> 0 && rax_12.d s<= rax_2 && arg1[rax_12 - 1] == 0)",
    "arg1[rax_12 - 1] = 0x20",
    "var_44 = 7",
    "arg1[sx.q(rax_2)] = 0",
    "char rax_14 = arg1[7]",
    "if (rax_14 == 0x20 || rax_14 == 9)",
    "void* rdx_2 = &arg1[8]",
    "void* r9_1",
    "while (true)",
    "rax_14 = *rdx_2",
    "r9_1 = rdx_2",
    "rdx_2 += 1",
    "if (rax_14 != 0x20)",
    "if (rax_14 != 9)",
    "break",
    "var_44 = r9_1.d - (&arg1[8]).d + 8",
    "if (rax_14 - 0x3c u<= 2 || rax_14 == 0x21)",
    "uint64_t rdi_7 = zx.q(sub_eaee0(arg1, &var_44))",
    "if (rdi_7.d s<= 0)",
    "sub_eb6a0(\"comparison operator expected, fo\u2026\", 0)",
    "int64_t rax_17 = sx.q(var_44)",
    "void* rsi_3 = &arg1[rax_17]",
    "char rdx_7 = *rsi_3",
    "if (rdx_7 == 0)",
    "label_eed0b:",
    "sub_eb6a0(\"numeric argument expected, found\u2026\", 0)",
    "void* rcx_3 = &arg1[rax_17 + 1]",
    "int32_t var_50",
    "int32_t r13_1 = var_50",
    "bool rax_18 = false",
    "int32_t r9_4 = rax_17.d + 1 - rsi_3.d",
    "void* r11_2 = rcx_3 - rsi_3",
    "bool r10_1",
    "while (true)",
    "r10_1 = rax_18",
    "int64_t r12_4",
    "r12_4.b = rdx_7 == 9",
    "rax_18 = rdx_7 == 0x20 | r12_4.b",
    "if (rax_18 == 0)",
    "break",
    "rdx_7 = *rcx_3",
    "r13_1 = r9_4 + rsi_3.d",
    "rcx_3 += 1",
    "rsi_3 += r11_2",
    "if (rdx_7 == 0)",
    "goto label_eed0b_2",
    "if (r10_1 != 0)",
    "var_44 = r13_1",
    "if (rdx_7 - 0x30 u> 9)",
    "label_eed0b_1:",
    "sub_eb6a0(\"numeric argument expected, found\u2026\", 0)",
    "int64_t r11_3 = sx.q(var_44)",
    "uint64_t r9_5 = 0",
    "char rdx_9 = arg1[r11_3]",
    "uint64_t r10_2 = r11_3",
    "int64_t rcx_5 = sx.q((r11_3 + 1).d)",
    "if (rdx_9 - 0x30 u<= 9)",
    "r11_3 = rcx_5",
    "r9_5 = zx.q(sx.d(rdx_9 - 0x30) + ((r9_5 * 5).d << 1))",
    "rdx_9 = arg1[rcx_5]",
    "rcx_5 += 1",
    "do while (rdx_9 - 0x30 u<= 9)",
    "var_44 = r11_3.d",
    "r10_2 = zx.q(r11_3.d)",
    "char rcx_6",
    "int32_t rdx_12",
    "if (rdx_9 == 0x2e)",
    "char rdx_25 = arg1[r11_3 + 1]",
    "if (rdx_25 - 0x30 u<= 9 || rdx_25 == 0)",
    "rdx_12 = (r10_2 + 1).d",
    "var_44 = rdx_12",
    "rcx_6 = arg1[sx.q(rdx_12)]",
    "if (rcx_6 - 0x30 u<= 9)",
    "int64_t rdx_27 = sx.q((r10_2 + 2).d)",
    "r10_2 = rdx_27",
    "r8_1 = zx.q(sx.d(rcx_6 - 0x30) + ((r8_1 * 5).d << 1))",
    "rcx_6 = arg1[rdx_27]",
    "rdx_27 += 1",
    "do while (rcx_6 - 0x30 u<= 9)",
    "var_44 = r10_2.d",
    "rdx_12 = r10_2.d",
    "goto label_ee803",
    "label_eed0b_2:",
    "sub_eb6a0(\"numeric argument expected, found\u2026\", 0)",
    "int64_t rsi_4 = sx.q(var_44)",
    "rdx_12 = rsi_4.d",
    "rcx_6 = arg1[rsi_4]",
    "label_ee803:",
    "int32_t var_54",
    "int32_t r12_6 = var_54",
    "int64_t rdx_14 = sx.q(rdx_12 + 1)",
    "if (rcx_6 != 0)",
    "bool r11_4",
    "while (true)",
    "r11_4 = rax_18",
    "r10_2.b = rcx_6 == 9",
    "rax_18 = rcx_6 == 0x20 | r10_2.b",
    "if (rax_18 == 0)",
    "break",
    "r12_6 = rdx_14.d",
    "rdx_14 += 1",
    "rcx_6 = arg1[rdx_14 - 1]",
    "if (rcx_6 == 0)",
    "goto label_eeab0",
    "if (r11_4 != 0)",
    "var_44 = r12_6",
    "if (rcx_6 == 0x23)",
    "goto label_eeab0",
    "sub_eb6a0(\"trailing garbage on line: `%s'\", 0)",
    "label_eeab0:",
    "int32_t rcx_10 = (r8_1 + (zx.q((r9_5 * 5).d) << 1)).d",
    "char var_4c",
    "if (rdi_7.d u<= 6)",
    "switch (rdi_7)",
    "case 1",
    "int32_t rax_39",
    "rax_39.b = rcx_10 == 0x52",
    "var_4c.d = rax_39",
    "case 2",
    "int32_t rax_41",
    "rax_41.b = rcx_10 != 0x52",
    "var_4c.d = rax_41",
    "case 3",
    "int32_t rax_40",
    "rax_40.b = rcx_10 s<= 0x51",
    "var_4c.d = rax_40",
    "case 4",
    "int32_t rax_38",
    "rax_38.b = rcx_10 s<= 0x52",
    "var_4c.d = rax_38",
    "case 5",
    "int32_t rax_37",
    "rax_37.b = rcx_10 s> 0x52",
    "var_4c.d = rax_37",
    "case 6",
    "int32_t rax_34",
    "rax_34.b = rcx_10 s> 0x51",
    "var_4c.d = rax_34",
    "_rl_parsing_conditionalized_out = var_4c ^ 1",
    "sub_eb6a0(\"comparison operator expected, fo\u2026\", 0)",
    "int32_t rax_7 = 1",
    "if (strcasecmp(&arg1[5], \"emacs\") != 0)",
    "int32_t rax_24 = strcasecmp(&arg1[5], \"vi\")",
    "int32_t rax_25 = neg.d(rax_24)",
    "rax_7 = sbb.d(rax_25, rax_25, rax_24 != 0)",
    "_rl_parsing_conditionalized_out = rl_editing_mode != rax_7",
    "label_ee5f0:",
    "if (strncasecmp(arg1, \"term=\", 5) != 0)",
    "goto label_ee60c",
    "uint64_t r12_7 = strlen(rl_terminal_name_1) + 1",
    "char* rax_20 = malloc(r12_7)",
    "if (rax_20 == 0)",
    "sub_a7f00()",
    "noreturn",
    "__strcpy_chk(rax_20, rl_terminal_name_1, r12_7)",
    "char* rax_21 = strchr(rax_20, 0x2d)",
    "if (rax_21 != 0)",
    "*rax_21 = 0",
    "if (strcasecmp(&arg1[5], rax_20) != 0)",
    "_rl_parsing_conditionalized_out_1 = strcasecmp(&arg1[5], rl_terminal_name) != 0",
    "_rl_parsing_conditionalized_out = _rl_parsing_conditionalized_out_1",
    "free(rax_20)",
    "*(fsbase + 0x28)",
    "if (rax == *(fsbase + 0x28))",
    "return 0",
    "__stack_chk_fail()",
    "noreturn"
  ]
}