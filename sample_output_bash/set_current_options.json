{
  "address": "0xc1d70",
  "rules": [
    "decrypt data using TEA/ab7f9f2b007f48f680d6bcb7da99c5f3/228e05560ef647b99ab605fac0daf580",
    "populate SysWhispers2 syscall list/074b321f7b7941958bfc8de4f583b5b2",
    "encrypt data using TEA/125a16c5ca784de5b4ec344bb7f45260/b9272fb9d4744824873ec7d3c8013c6c",
    "connect to WMI namespace via WbemLocator/472165133b624c67bbc5d17c3915a018",
    "log keystrokes via raw input data/5b32ff98460e406e86dc2ef8d82ba1a5",
    "encrypt data using XXTEA/55da17cb2d2b4f30ac54eab7c66fa3d3/053ec9add6b744e4993f7dc6e62f924f",
    "check Internet connectivity via WinINet/4ebebc1fd30e4dc8aec0393f85edc8f3",
    "contain loop",
    "check OS version/35d8fd86b2bf418898b01c7af02eb9bc",
    "encrypt data using XTEA/5c1c4c90f3124e8b8e496a40b647bc29/214603c8f1d64a2ea9add8dd99e7e802",
    "check OS version/a792de506c61438eae0e98a59003db67",
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a"
  ],
  "disassembly": [
    "endbr64 ",
    "test    rdi, rdi",
    "je      0xc1ed2",
    "retn     {__return_addr}",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "lea     r15, [rel data_11f68a]  {\"allexport\"}",
    "push    r14 {__saved_r14}",
    "mov     r14d, 0x1",
    "push    r13 {__saved_r13}",
    "push    r12 {var_28}",
    "push    rbx {__saved_rbx}",
    "mov     rbx, rdi",
    "sub     rsp, 0x8",
    "lea     rax, [rel o_options]",
    "lea     r13, [rax+0x8]  {data_155a08}",
    "jmp     0xc1dff",
    "cmp     byte [rbx+r14-0x1], 0x1",
    "mov     edi, dword [r13]",
    "sbb     r12d, r12d",
    "and     r12d, 0xfffffffe",
    "add     r12d, 0x2d",
    "test    edi, edi",
    "je      0xc1db0",
    "mov     rax, qword [r13+0x18]",
    "test    rax, rax",
    "je      0xc1e70",
    "lea     rsi, [rel shell_flags]",
    "xor     ecx, ecx  {0x0}",
    "mov     eax, 0x61",
    "lea     rdx, [rsi+0x10]  {data_1558b0}",
    "jmp     0xc1e42",
    "mov     rax, qword [r13+0x8]",
    "mov     eax, dword [rax]",
    "jmp     0xc1dc2",
    "mov     rdi, r15",
    "call    rax",
    "cmp     edi, eax",
    "jne     0xc1e30",
    "cmp     eax, 0x1",
    "sbb     eax, eax",
    "and     eax, 0xfffffffe",
    "add     eax, 0x2d",
    "cmp     r12d, eax",
    "je      0xc1de7",
    "mov     r15, qword [r13+0x20]",
    "lea     rax, [r14+0x1]",
    "add     r13, 0x28",
    "test    r15, r15",
    "je      0xc1e98",
    "mov     rax, qword [r13+0x10]",
    "test    rax, rax",
    "je      0xc1e80",
    "movsx   eax, byte [rdx]",
    "add     rdx, 0x10",
    "add     ecx, 0x1",
    "test    al, al",
    "je      0xc1ed3",
    "movsxd  rcx, ecx",
    "shl     rcx, 0x4",
    "mov     rax, qword [rsi+rcx+0x8]",
    "cmp     dword [rax], 0x1",
    "sbb     eax, eax",
    "and     eax, 0xfffffffe",
    "add     eax, 0x2d",
    "cmp     r12d, eax",
    "je      0xc1de7",
    "movsxd  r14, r14d",
    "lea     rdx, [rel interactive_comments]",
    "xor     eax, eax  {0x0}",
    "lea     rsi, [rel data_156600]",
    "lea     rdi, [rbx+r14]",
    "nop     ",
    "mov     r14, rax",
    "xor     edx, edx  {0x0}",
    "mov     rax, qword [r13+0x8]",
    "cmp     r12d, 0x2d",
    "sete    dl",
    "mov     dword [rax], edx",
    "jmp     0xc1de7",
    "mov     rsi, r15",
    "mov     edi, r12d",
    "call    rax",
    "jmp     0x324af",
    "mov     esi, r12d",
    "call    change_flag",
    "jmp     0xc1de7",
    "movsx   ecx, byte [rdi+rax]",
    "add     rax, 0x1",
    "mov     dword [rdx], ecx",
    "mov     rdx, qword [rsi+rax*8]",
    "test    rdx, rdx",
    "jne     0xc1eb0",
    "add     rsp, 0x8",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {var_28}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "mov     eax, dword [0x0]  {0x464c457f}",
    "ud2     ",
    "{ Does not return }"
  ],
  "high level IL": [
    "if (arg1 == 0)",
    "return ",
    "char const* const r15 = \"allexport\"",
    "int64_t r14 = 1",
    "uint64_t var_28 = arg2",
    "void* const r13 = &data_155a08",
    "while (true)",
    "int32_t rdi_2 = *r13",
    "arg2 = zx.q((sbb.d(arg2.d, arg2.d, *(arg1 + r14 - 1) u< 1) & 0xfffffffe) + 0x2d)",
    "if (rdi_2 == 0)",
    "int64_t rax_1 = *(r13 + 0x18)",
    "int32_t rax_2",
    "if (rax_1 == 0)",
    "rax_2 = **(r13 + 8)",
    "rax_2 = rax_1(r15)",
    "if (arg2.d != (sbb.d(rax_2, rax_2, rax_2 u< 1) & 0xfffffffe) + 0x2d)",
    "int64_t rax_6 = *(r13 + 0x10)",
    "if (rax_6 == 0)",
    "int32_t rdx_2",
    "rdx_2.b = arg2.d == 0x2d",
    "**(r13 + 8) = rdx_2",
    "rax_6(zx.q(arg2.d), r15)",
    "int32_t rcx_1 = 0",
    "int32_t rax_8 = 0x61",
    "void* const rdx_1 = &data_1558b0",
    "while (rdi_2 != rax_8)",
    "rax_8 = sx.d(*rdx_1)",
    "rdx_1 += 0x10",
    "rcx_1 += 1",
    "if (rax_8.b == 0)",
    "trap(6)",
    "int32_t* rax_9 = (&data_1558a8)[sx.q(rcx_1) * 2]",
    "if (arg2.d != (sbb.d(rax_9.d, rax_9.d, *rax_9 u< 1) & 0xfffffffe) + 0x2d)",
    "change_flag(rdi_2, arg2.d)",
    "r15 = *(r13 + 0x20)",
    "r13 += 0x28",
    "if (r15 == 0)",
    "break",
    "r14 += 1",
    "uint32_t* i = &interactive_comments",
    "int64_t rax_15 = 0",
    "uint32_t rcx_4 = sx.d(*(arg1 + sx.q(r14.d) + rax_15))",
    "rax_15 += 1",
    "*i = rcx_4",
    "i = (&data_156600)[rax_15]",
    "do while (i != 0)",
    "return "
  ]
}