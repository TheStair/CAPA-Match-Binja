{
  "address": "0xbf1c0",
  "rules": [
    "decrypt data using TEA/ab7f9f2b007f48f680d6bcb7da99c5f3/228e05560ef647b99ab605fac0daf580",
    "populate SysWhispers2 syscall list/074b321f7b7941958bfc8de4f583b5b2",
    "encrypt data using TEA/125a16c5ca784de5b4ec344bb7f45260/b9272fb9d4744824873ec7d3c8013c6c",
    "hash data using aphash/e04b32e4de024de7af9a97876e98ac22",
    "connect to WMI namespace via WbemLocator/472165133b624c67bbc5d17c3915a018",
    "encrypt data using XXTEA/55da17cb2d2b4f30ac54eab7c66fa3d3/053ec9add6b744e4993f7dc6e62f924f",
    "contain loop",
    "hash data with CRC32/b31bffa9a15b460bbcbd04d2822872fb",
    "encrypt data using XTEA/5c1c4c90f3124e8b8e496a40b647bc29/214603c8f1d64a2ea9add8dd99e7e802",
    "write file on Windows/dbc9cc37967145a499adfa89f5005055",
    "check for kernel debugger via shared user data structure/6be60e61779449d185f0bab196679834",
    "validate payment card number using luhn algorithm with no lookup table/2ca16ccf2c974f3f90e3b8d02944442a",
    "check for time delay via GetTickCount/173be9e5d4d440c09f85224fcb793b6a"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "push    r15 {__saved_r15}",
    "push    r14 {__saved_r14}",
    "lea     r14, [rbp-0x60 {var_68}]",
    "push    r13 {__saved_r13}",
    "mov     r15, r14 {var_68}",
    "push    r12 {__saved_r12}",
    "lea     r12, [rel data_11f68a]  {\"allexport\"}",
    "push    rbx {__saved_rbx}",
    "xor     ebx, ebx  {0x0}",
    "sub     rsp, 0x48",
    "mov     rax, qword [fs:0x28]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "xor     eax, eax  {0x0}",
    "lea     rax, [rel o_options]",
    "lea     r13, [rax+0x8]  {data_155a08}",
    "jmp     0xbf23b",
    "mov     esi, dword [r13]",
    "mov     byte [r15], 0x0",
    "test    esi, esi",
    "je      0xbf208",
    "mov     rax, qword [r13+0x18]",
    "test    rax, rax",
    "je      0xbf290",
    "lea     r8, [rel shell_flags]",
    "xor     ecx, ecx  {0x0}",
    "mov     eax, 0x61",
    "lea     rdx, [r8+0x10]  {data_1558b0}",
    "jmp     0xbf26e",
    "mov     rax, qword [r13+0x8]",
    "jmp     0xbf283",
    "mov     rdi, r12",
    "call    rax",
    "test    eax, eax",
    "je      0xbf22a",
    "cmp     esi, eax",
    "jne     0xbf260",
    "mov     esi, dword [rax]",
    "test    esi, esi",
    "jne     0xbf21a",
    "mov     r12, qword [r13+0x20]",
    "add     r15, 0x1",
    "add     r13, 0x28",
    "test    r12, r12",
    "je      0xbf2a0",
    "mov     rdi, r12",
    "call    strlen",
    "mov     byte [r15], 0x1",
    "lea     ebx, [rbx+rax+0x1]",
    "movsx   eax, byte [rdx]",
    "add     rdx, 0x10",
    "add     ecx, 0x1",
    "test    al, al",
    "je      0xbf22a",
    "movsxd  rcx, ecx",
    "shl     rcx, 0x4",
    "mov     rax, qword [r8+rcx+0x8]",
    "test    rax, rax",
    "je      0xbf22a",
    "jmp     0xbf22a",
    "add     ebx, 0x1",
    "movsxd  rbx, ebx",
    "mov     rdi, rbx",
    "call    malloc",
    "mov     r15, rax",
    "test    rax, rax",
    "je      0xbf3c5",
    "mov     rsi, rbx",
    "lea     rdi, [rel data_11f01e]  {\"xmalloc\"}",
    "xor     eax, eax  {0x0}",
    "call    sub_a7f00",
    "{ Does not return }",
    "lea     rax, [rel o_options]",
    "xor     ecx, ecx  {0x0}",
    "lea     r13, [rel data_11f68a]  {\"allexport\"}",
    "lea     r12, [rax+0x28]  {data_155a28}",
    "jmp     0xbf2e1",
    "cmp     byte [r14], 0x0",
    "je      0xbf2d0",
    "mov     r13, qword [r12]",
    "add     r14, 0x1",
    "add     r12, 0x28",
    "test    r13, r13",
    "je      0xbf320",
    "movsxd  rdi, ecx",
    "mov     rsi, r13",
    "mov     dword [rbp-0x64 {var_6c_1}], ecx",
    "cmp     rbx, rdi",
    "mov     rdx, rdi",
    "cmovae  rdx, rbx",
    "sub     rdx, rdi",
    "add     rdi, r15",
    "call    __strcpy_chk",
    "mov     rdi, r13",
    "call    strlen",
    "mov     ecx, dword [rbp-0x64 {var_6c_1}]",
    "add     eax, ecx",
    "lea     ecx, [rax+0x1]",
    "cdqe    ",
    "mov     byte [r15+rax], 0x3a",
    "jmp     0xbf2d0",
    "mov     rax, r15",
    "test    ecx, ecx",
    "je      0xbf331",
    "mov     byte [rax], 0x0",
    "lea     r12, [rel data_11ffa4]",
    "mov     ebx, 0x1",
    "mov     rdi, r12  {data_11ffa4, \"SHELLOPTS\"}",
    "call    find_variable",
    "test    rax, rax",
    "je      0xbf35d",
    "sub     ecx, 0x1",
    "movsxd  rcx, ecx",
    "lea     rax, [r15+rcx]",
    "xor     edx, edx  {0x0}",
    "mov     rsi, r15",
    "mov     rdi, r12  {data_11ffa4, \"SHELLOPTS\"}",
    "call    bind_variable",
    "mov     edx, dword [rax+0x28]",
    "mov     ecx, edx",
    "or      ecx, 0x2",
    "mov     dword [rax+0x28], ecx",
    "lea     rcx, [rel mark_modified_vars]",
    "mov     ecx, dword [rcx]  {mark_modified_vars}",
    "test    ecx, ecx",
    "je      0xbf386",
    "mov     ebx, dword [rax+0x28 {Elf64_Header::section_header_offset.d}]",
    "mov     edx, ebx",
    "not     ebx",
    "and     edx, 0xfffffffd",
    "and     ebx, 0x1",
    "mov     dword [rax+0x28 {Elf64_Header::section_header_offset.d}], edx",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "sub     rax, qword [fs:0x28]",
    "jne     0xbf3c0",
    "test    bl, bl",
    "jne     0xbf3b0",
    "call    __stack_chk_fail",
    "{ Does not return }",
    "add     rsp, 0x48",
    "mov     rdi, r15",
    "pop     rbx {__saved_rbx}",
    "pop     r12 {__saved_r12}",
    "pop     r13 {__saved_r13}",
    "pop     r14 {__saved_r14}",
    "pop     r15 {__saved_r15}",
    "pop     rbp {__saved_rbp}",
    "jmp     free",
    "test    dl, 0x1",
    "je      0xbf386",
    "and     edx, 0xfffffffe",
    "or      edx, 0x2",
    "mov     dword [rax+0x28], edx",
    "jmp     0xbf386"
  ],
  "high level IL": [
    "void var_68",
    "void* r14 = &var_68",
    "void* r15 = &var_68",
    "char const* const i = \"allexport\"",
    "int32_t rbx = 0",
    "void* fsbase",
    "int64_t rax = *(fsbase + 0x28)",
    "void* const r13 = &data_155a08",
    "int32_t rsi_1 = *r13",
    "*r15 = 0",
    "int32_t* rax_5",
    "if (rsi_1 == 0)",
    "int64_t rax_1 = *(r13 + 0x18)",
    "if (rax_1 == 0)",
    "rax_5 = *(r13 + 8)",
    "label_bf285:",
    "if (*rax_5 != 0)",
    "goto label_bf21d",
    "if (rax_1(i, rsi_1) != 0)",
    "label_bf21d:",
    "int32_t rax_3 = strlen(i)",
    "*r15 = 1",
    "rbx = rbx + rax_3 + 1",
    "int32_t rcx_1 = 0",
    "int32_t rax_4 = 0x61",
    "void* const rdx_1 = &data_1558b0",
    "if (rsi_1 == rax_4)",
    "rax_5 = (&data_1558a8)[sx.q(rcx_1) * 2]",
    "if (rax_5 == 0)",
    "goto label_bf22a",
    "goto label_bf285",
    "rax_4 = sx.d(*rdx_1)",
    "rdx_1 += 0x10",
    "rcx_1 += 1",
    "do while (rax_4.b != 0)",
    "label_bf22a:",
    "i = *(r13 + 0x20)",
    "r15 += 1",
    "r13 += 0x28",
    "do while (i != 0)",
    "int64_t bytes = sx.q(rbx + 1)",
    "char* rax_6 = malloc(bytes)",
    "if (rax_6 == 0)",
    "sub_a7f00()",
    "noreturn",
    "int32_t bytes_3 = 0",
    "char const* const i_1 = \"allexport\"",
    "char const (** const r12)[0xc] = &data_155a28",
    "if (*r14 != 0)",
    "int64_t bytes_2 = sx.q(bytes_3)",
    "int64_t bytes_1 = bytes_2",
    "if (bytes u>= bytes_2)",
    "bytes_1 = bytes",
    "__strcpy_chk(&rax_6[bytes_2], i_1, bytes_1 - bytes_2)",
    "int32_t rax_8 = strlen(i_1) + bytes_3",
    "bytes_3 = rax_8 + 1",
    "rax_6[sx.q(rax_8)] = 0x3a",
    "i_1 = *r12",
    "r14 += 1",
    "r12 = &r12[5]",
    "do while (i_1 != 0)",
    "void* rax_10 = rax_6",
    "if (bytes_3 != 0)",
    "rax_10 = &rax_6[sx.q(bytes_3 - 1)]",
    "*rax_10 = 0",
    "char rbx_2 = 1",
    "struct Elf64_Header* rax_11 = find_variable(\"SHELLOPTS\")",
    "if (rax_11 != 0)",
    "int32_t rbx_3 = rax_11->section_header_offset.d",
    "rbx_2 = (not.d(rbx_3)).b & 1",
    "rax_11->section_header_offset.d = rbx_3 & 0xfffffffd",
    "void* rax_12 = bind_variable(\"SHELLOPTS\", rax_6, 0)",
    "int32_t rdx_5 = *(rax_12 + 0x28)",
    "*(rax_12 + 0x28) = rdx_5 | 2",
    "if (mark_modified_vars != 0 && rbx_2 != 0 && (rdx_5.b & 1) != 0)",
    "*(rax_12 + 0x28) = (rdx_5 & 0xfffffffe) | 2",
    "*(fsbase + 0x28)",
    "if (rax == *(fsbase + 0x28))",
    "return free(rax_6) __tailcall",
    "__stack_chk_fail()",
    "noreturn"
  ]
}